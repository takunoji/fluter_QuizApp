# fluter_complete_guide

A new Flutter project.
Udemy
Flutter & Dart - The Complete Guide [2023 Edition]
0:03 / 6:31

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.


さて､ いよいよFlutterを使い始め､ その詳細について学ぶ時が来ました｡

次のコースモジュールでは､ Flutterの重要な基礎のすべてに飛び込みます｡

Flutterの仕組み､ そこにあるコアウィジェット､ ウィジェットでユーザーインターフェースを構築する方法など､ すべてを学びますので､

もちろんそれは重要なモジュールとなるでしょう｡

その後､ デバッグのセクションに進みます｡

もちろん､ 開発中にうまくいかないこともありますし､

エラーを発見して修正することは､

開発者として重要なことです｡

これらのコンセプトは､ 単に退屈な理論で教えるのではなく､ コース全体を通して1つのアプリだけでなく､ 基本セクション用のアプリ､

より高度なウィジェットセクション用の別のアプリなど､ コース全体を通していくつかのアプリを用意し､ あるセクションだけのアプリや複数のセクションで異なるコンセプトを示すアプリも用意していることは､

特筆すべきことです｡

また､

しばらくしてコースに戻ったときや､ あるセクションをスキップしたいときにも､ 私たちが取り組んでいるプロジェクトの大きな塊を見逃すことがなく､

代わりに多くのセクションが独自のプロジェクトを持っているので､

より簡単に取りかかることができるという利点があります｡ より現実的なウィジェットのスタイリングと構築について詳しく見た後､

レスポンシブで適応性の高いユーザーインターフェースの構築方法についても学びます｡

レスポンシブとは､

さまざまなデバイスサイズに対応するユーザーインターフェースのことで､ アダプティブとは､

ユーザーインターフェースが､ AndroidやiOSなど､ 基盤となるプラットフォームに適応し､

必要に応じて異なるウィジェットやレイアウトをレンダリングすることを指します｡

その後､ Flutterのコアとなる基礎部分をしっかりと理解した上で､

内部を深く掘り下げていきます｡

Flutterとそのウィジェットが内部でどのように動作しているか､ 何かが変更されたときにアプリがどのように再レンダリングされるか､

そしてパフォーマンスを向上させアプリの動作を改善するためにコードを最適化する方法について見ていきます｡

それはさておき､

新しいアプリと､ 全く新しいトピック､ ナビゲーション､ マルチスクリーンをご紹介します｡ ここまでの講座では､ 必ず1画面のみで作業をしてきましたが､ ほとんどのアプリは2画面以上あります｡

ここでは､ 商品画面､ カード画面､ ユーザープロファイル画面など､

さまざまな画面を設定し､ アプリ内のページを切り替えられるようにするための方法を学びます｡

また､ 大規模なアプリでは､ アプリやアプリのさまざまな部分が必要とするデータを正しく管理するのがかなり面倒になるため､

状態管理について検討することになります｡

このコースでは､ データや状態を管理するためのさまざまなオプションについて学びますが､

これは最終的には､ 変化するデータの別の用語と言えます｡

このモジュールでは､

ナビゲーションとマルチスクリーンのセクションで行ったのと同様に､ 新しいプロジェクトを開始します｡

この時点まで､ 私たちは常にデバイス上で動作していましたが､

いくつかのデータはウェブ上のデータベースに保存する必要があります｡

ほとんどのアプリケーションは何らかの認証を必要とします｡ したがって､ ユーザー認証に飛び込んで､ ユーザーをログインさせ､ サインアップさせ､

ログアウトさせ､ アプリのライフタイムを通じてユーザーのセッションを管理する方法を学びましょう｡

その後､ アニメーションについて見ていきます｡ アニメーションはアプリケーションにとって重要な要素です｡

なぜなら､ 画面上で何が変化したかについて､ より良いフィードバックをユーザーに与えることができるからです｡ Flutterが提供する組み込みのアニメーション技術についてすべて学び､

それらを使って素晴らしいユーザー体験とユーザーインターフェイスを作る方法を学びます｡

現在､

ほとんどのネイティブアプリは､ カメラ､ マップ､ デバイス上のストレージなど､ 特定のデバイス機能にアクセスする必要があります｡ したがって､

これもこのモジュールで徹底的に調べます｡ このモジュールでも新しいアプリケーションを作成し､

デバイスのカメラの使い方､ 画像の撮影方法､ デバイスへの保存方法､ Googleマップの使用方法､

ユーザーの位置情報の取得方法などを学びます｡

さて､ 時にはFlutterに組み込まれていないネイティブデバイスの機能が必要になり､ Flutterからそれにアクセスする簡単な方法がない場合があります｡

カメラと地図は内蔵されていますが､ 内蔵されていない使い方もあるかもしれません｡

ネイティブデバイスのコード､ 例えばAndroidのJavaコードやiOSのSwiftコードを実行する方法も学びます｡

そのコードをFlutterアプリに接続して､ 1つのプロジェクトを持っていても､ Flutterに組み込まれていない場合は､ Flutterアプリの中からネイティブデバイスのコードをトリガーして実行できます｡

これはとてもクールな機能で､ このコースでも取り上げます｡

さて､ これらがすべて完了したら､ もちろんアプリを公開するときです｡ ここでは､ アプリを構築して最適化し､

Apple App StoreまたはGoogle Playストアに公開する方法を紹介します｡

さてと､ これでおしまいです｡

そして､ コースの締めくくりとして､

次のステップを紹介し､ さらに､

優れたアプリを開発するための青写真とでもいうべきものを提供します｡

このように､ このコースにはたくさんのコンテンツが用意されているんです｡ 気に入ってもらえるといいのですが､ 私たちはたくさんのアプリを作っています｡

したがって､ 講座が終わるころには､ 素晴らしいFlutterアプリを作り､

Flutterの力を借りてどんなアプリでも作ることができるという､ 本当に自信を持てるようになっているはずです｡

##########
さて､ コースの中身がわかったところで､ どうすればこのコースを最大限に活用できるかを考えてみましょう｡

だから､ もちろん動画は見た方がいい､ やっぱりビデオオンデマンドのコースだから｡

自分のスピードで見て､ 速すぎたら一時停止して巻き戻してください｡

もし､ 私が早すぎると感じたら､ スピードを落とすか､

一時停止して､ もう一度ビデオの最初に戻ってください｡

そのような生徒のためにも良いコースを作りたいので､ ビデオではあまり長いポーズをとっていませんが､

私が本当にお勧めするのは､ コードを書くことです｡

また､

講座の中にあるクイズや､ 私が用意した練習問題もやってみてください｡

そうやって､ 自分のアプリを作り､ 私のアプリの自分なりのバージョンを作ることが､ 最終的に一番学べる方法だからです｡

また､ コースの様々な講義に添付しているスライドやチートシートは､

しばらく経ってからこのコースに戻ってきたり､ 自分のプロジェクトに取り組んだりするときに､

本当に役立つリソースとなります｡

もし､ あなたが行き詰まり､ 私のコードとあなたのコードを比較したならば､ それは常に最初に行うべきことですが､ もちろん､

Q&Aセクションで質問することも可能です｡

ほとんどのエラーはコードを比較することで簡単に修正できますし､ 私が教えても何が間違っているのか理解できないよりも､

自分でエラーを発見して修正する方がずっと多くのことを学べるからです｡

Q&Aコーナーで質問するだけでなく､

他の人を助けることも大切です｡ 自分の問題であれ､ 他の人の問題であれ､ 問題を掘り下げて解決し､ 答えを書き留め､ その問題について考え､

自分の答えが正しいかどうかを判断すれば､ 最も身につくからです｡

もちろん､

間違った答えを出すかもしれませんが､

それは問題ではありません｡

だから絶対にこの機会を利用して､

このコースを最大限に活用してください｡



######################

では､ Flutterに飛び込んでみましょう｡

そのために､ 基本的なことに飛び込みます｡

基本的なことがたくさんあるので､ 長いモジュールになります｡

また､ 付属の資料やチートシート､ ドキュメント､ 講義の間に挟んであるテキストなどをご覧になり､

より深く理解していただくことを強くお勧めします｡

このモジュールが終わる頃には､

素晴らしいFlutterアプリを作るために必要なコアな基礎知識をたくさんカバーしていることでしょう｡

では､ このセクションには一体何があるのでしょうか？

Flutterアプリが実際にどのように起動し､ どのように動作するのか､ そこで実際に何が起きているのか､ Flutterアプリがどのように画面に何かをもたらすのかを見ていきます｡

ウィジェットを使って､

カスタムウィジェットを構築していきます｡

ユーザーイベント､ すなわちユーザーがボタンをタップしたときのボタン押下への反応方法について学びます｡

ウィジェットには大きく分けてステートレスウィジェットとステートフルウィジェットの2種類の違いがあることを学び､ どのような違いがあるのか､

どのような場合にどのウィジェットを使用するのかについて学びます｡ なぜなら､ 前もってDartを学んでおいて､ 1時間か2時間後に作り始めるよりも､

作りながら学ぶ方がずっと面白いからです｡

このコースでは､

具体的なFlutterアプリでそのすべてを学びますが､ 間違いなく最も美しいものではありません｡

複数のファイルにまたがってたくさんのコードを書き､

独自のウィジェットを作り､ データの受け渡し､ データの管理､ ある程度のスタイリング､ そしてDartとFlutterのコア機能について多くを学ぶことができます｡

では､ 潜入してみましょう｡

#####
さて､ コースの紹介とすべての基本が終わり､ FlutterとAndroid Studioなどがシステムにインストールされたので､

いよいよFlutter開発に飛び込み､ flutterとdartを学ぶ時が来ました｡

そのために､ ここに新しいプロジェクトを作成します｡

そのためには､ やはりcdコマンドを使って､ システム上にあるプロジェクトを作成したいフォルダに移動します｡

そしてターミナルかコマンドプロンプトで､ flutter, createを実行して新しいプロジェクトを作り､ 好きな名前を付けます｡

私はflutter underscore complete underscore guideと名付けます｡

プロジェクト名は自由ですが､ ドットやダッシュ､ ホワイトスペースは含まないでください｡

その代わり､ 複数の単語がある場合は､ アンダースコアで区切ってください｡

また､ ここで使っているように､ すべて小文字の名前を使うのが慣例となっています｡

そして､ 単純にEnterキーを押すだけです｡

そして学んだように､ これは以前ナビゲートしたパスに新しいフォルダを作成し､ そのフォルダに初期のflutterプロジェクトファイルを保存します｡

そして､ 再びVisual Studio codeまたはAndroid studioを使ってそのフォルダを開くことができます｡

そしてこれが私がここで行ったことで､ Flutterプロジェクトがここにあるのです｡

さて､ このFlutterプロジェクトにはWebフォルダがありますが､ ここではWeb用にビルドするつもりはないので､

このフォルダを削除します｡

だから､ それをゴミ箱に移動して､ 今そこにある他のフォルダとファイルはすべて残しておきます｡

これらのフォルダとファイル､ そしてそれらの機能について､ 次回の講義で説明します｡

とりあえず､ 同じようなスタートダッシュの企画を確認したいんです｡

そして､ この添付ファイルを確実にするために､ あなたは私のpops backdoored yamlファイルとメインのdot dartファイルを見つけ､

あなたのメインのdartファイルを私のものに置き換え､ あなたのlibフォルダにある他のファイルやフォルダを私のものに削除し､ あなたのpup

spectral yamlファイルを私のものに置き換える必要があります｡

これは本当に大事なことです｡

さて､ YAMLファイルのポップアスペクトに関する重要な注意点として､ 私は自分のプロジェクトにFlutter Complete Guideという名前をつけたので､

もしプロジェクトに違う名前をつけたらエラーが出るかもしれません｡

その場合､ どうすればいいかというと､ プロジェクト名を取ることです｡

で､ プロジェクトフォルダの名前ですが､ 私の場合はflatter complete guideです｡

しかし､ もしここで違う名前をつけていた場合､ Flutter Createでプロジェクトを作成するときに違う名前を選んだ場合は､

flutter complete guideではなく､ YAMLファイルのpopの部分にその名前を差し込む必要があります｡

また､ こちらのウィジェットテストのdartファイルでは､ エラーが発生する場合があります｡

プロジェクトにメインのDodge Dartファイルを追加した後､ このテストファイルは自動テストのためにあるもので､ このコースでやることではないので､

このエラーは無視しても大丈夫です｡

しかし､ その問題を解消するには､ テストフォルダやそのテストファイルを削除すればよいのです｡ なぜなら､ そのテストファイルは必要ないからです｡

代わりにlibフォルダで作業します｡ なぜなら､ libフォルダにはアプリケーションのために書くコードを置くからです｡

それから､ このターミナルを開くとよいでしょう｡

そして､ そのターミナルでflutterパッケージを実行すると､ 取得できます｡

通常､ Flutterは舞台裏で自動的に実行されるはずなので､ これは必要ないでしょう｡

しかし､ これはFlutterがあなたに提供したPUP Spectral YAMLファイルを確実にピックアップするために重要なことなのです｡

これは､ 私たちが同じページでスタートし､ みなさんがスムーズについていけるようにするために､ 本当に重要なことです｡

さて､ 次回の講義でお話したように､ これらのフォルダーやファイルについて説明します｡

とりあえず､ ここでこのプロジェクトをエミュレータ上のアプリケーションとして起動できることを確認したいのですが､

エミュレータはiOSでもAndroidでもどちらでもかまいません｡

でも､ Windowsユーザーも含めてみんながAndroidのエミュレーターを使えるようになるのだから､ そっちを目指そう｡

そこで､ 前回のコードセクションと同じように､ もう一度エミュレータをさっと立ち上げてみます｡

もちろん､ 前節のものがまだ残っているかもしれませんし､ そのときは絶対にそれを使ってください｡

ではここで､ そのエミュレータをさっそくセットアップしてみます｡

ターミナルを開き､ 新しいターミナルでflutter runを実行するか､

前回の講座で学んだように､ runでデバッグせずに実行することもできます｡

そして､ これが自動的に実行されるはずです｡

ここで､ プロジェクトを実行する方法を選択するドロップダウンが表示されるかもしれませんが､ ここではDartとFlutterを選択し､

アプリケーションを実行します｡

Androidエミュレータ上でAndroidに､ 自動的にAndroidアプリとしてビルドします｡

ここでは､ このAndroidエミュレータを立ち上げていますので｡

さて､ これを初めて実行すると､ 前回の講座の項で見たように､ 少し時間がかかることがあります｡

この作業が終わると､ Androidエミュレーター上でカウンターアプリが再び動作するようになります｡ そして､

このコントロールパネルを使って､ 必要なときにいつでもこのアプリをリロードできるようになります｡

しかし､ 前回の講座のセクションで紹介したように､ コードを変更し､ コードの変更を保存するたびに

このFlutterアプリの実行方法の素晴らしいところは､ コードを変更するたびに自動的に再読み込みされることです｡

それでは､ 起動するのを楽しみに待ちましょう｡

そして､ ここからが本番です｡

このアプリケーションを紹介します｡

また､ 起動したばかりだと､ まだ少し遅いかもしれませんが､ すぐに反応が良くなるはずです｡

そして､ ここで遊んでみてください｡

そして､ ここにコードを編集してください｡

それゆえ､ 今､ 私たちはそれを実行しようとしているのです｡

すべての談話欄について｡

次回の講義では､ ここで手に入れたファイルやフォルダーが何をするものなのかを探っていきます｡

###
だから､ ここにはかなりの数のフォルダとファイルがある｡

さて､ ここにある多くのファイルは設定のためだけに存在し､ ここにある多くのフォルダもあなたが触る必要はありませんが､

それぞれのフォルダとファイルが何をするのかを説明しましょう｡

上から順番に見ていきましょう｡

このideaフォルダには､ Android Studioの設定項目が格納されています｡

ここでは､ Android Studioを使用していないので､ 特に変更する必要はありません｡

ビアコードは､ 持っていないかもしれないフォルダーです｡

今回､ 追加で設定したため､ ここにあります｡

私のコードと､ あなたがVSコードに設定したものが見えるように､ ズームレベルを設定しました｡

ここにあるあなたのvisualstudioコードプロジェクトは､ このような衝突ファイルで終わってしまうので､ ここに特別な開発オプションがないのであれば､それは必要ないでしょう｡

Androidのフォルダは超重要です｡
また､ Flutterを使わずに作成することも可能で､ 完全なAndroidプロジェクトを保持します｡

これは最終的にFlutter SDKがあなたのFlutterコードとマージするために使用するプロジェクトですと言えるかもしれません｡

つまり､ flutterのコードがネイティブコードにコンパイルされると､ 基本的にこのAndroidプロジェクトに注入される､と言えるでしょう｡

このAndroidプロジェクトは､ 後に本物のAndroidアプリに組み込まれる予定です｡

これで通常のAndroidプロジェクトとコンパイルされたflutterのコードが完成しました｡

そして､ ここで何かを変更する必要がある場合､ ほとんどの場合､ ここはFlutterが使用するパッシブフォルダなので､超重要ですが､ あなたが作業するフォルダではありません､ と言っておきます｡

ビルドフォルダも非常に重要です｡
最終的に､ これがflutterアプリケーションの出力を保持します｡
この場合､ いくつかのAndroidやJavaのファイルもあり､ このフォルダはFlutter SDKによって生成・管理されます｡
中身は何も変えない方がいい｡
これはすべて､ 開発時や､ コースの最後に行うデプロイのためのアプリ構築時にFlutterSDKが自動的に行うため､ パッシブフォルダにもなっています｡
そのため､ これまでのところ､ 私たちが仕事をするようなフォルダはありません｡

iOSのフォルダーも同様です｡
Androidのフォルダには､ 開発用と本番用の両方のAndroidプロジェクトを構築するために重要な､完全なAndroidプロジェクトがありました｡

そして､ iOSフォルダは､ 単に､ iOSプロジェクトと同じで､ これは通常のXcodeプロジェクトを保持します｡
Xcodeは､ Mac OSのiOSアプリの開発環境です｡
また､ Androidのフォルダと同様に､ 本当にあまり作業しないフォルダです｡
ここで作業をする場面もありますが､ その場合はその旨を記載しておきます｡
ほとんどの場合､ これはパッシブフォルダで､ 最終的にはあなたのフラッターコードにマージされ､Flutter SDKによって管理され､ 開発およびテスト用のiOSアプリケーションと､ あなたがデプロイする実際のアプリケーションの両方を取得します｡

libフォルダは､ 今や私たちにとって重要なフォルダです｡
libはライブラリの略で､ 作業の99％をこのフォルダで行うことになります｡
これは､ すべてのdartファイルを追加するフォルダです｡
Dartは､ FlutterがFlutterアプリケーションのコードを書くために使うプログラミング言語です｡
つまり､ このフォルダにファイルを追加したり､ コードを書き込んだりします｡
これは､ 私たちにとって超重要なフォルダです｡

testフォルダは､ ここではあまり重要でないフォルダです｡
アプリケーションのテスト､ 自動テストを書くことができるのです｡
つまり､ 基本的には私たちのコードを実行し､ 特定の事柄についてテストするコードです｡
確かに､ もう少し上級のdartやflutterの開発者になれば重要ですが､ 今の私たちにとっては重要ではないので､これは無視しても大丈夫です｡

Get ignoreは､ ソースコード管理ツールであるGitを使っているときに役立つフォルダです｡
コードのスナップショットを作成し､ 保存しておけば､ 後でそのスナップショットに戻ることができます｡
もし何かを失敗したり､ 何かを変更したい場合､ gitは必ず使わなければならないツールではありませんが､ 開発中にはしばしば本当に役に立つことがあります｡
この講義の後に､ gitに関する短いテキスト講義をご覧いただけます｡
使うかどうかは完全に任意ですが､ もし使ってみたい､ 面白そうだと思ったら､
そのレクチャーで始めてみて､ 使いたいと思ったら使えばいいんです｡

メタデータファイルは､ 実際に作業するファイルではありません｡
flutterで自動的に管理されます｡
そして最終的にflutterツールは､ アプリケーションを正しく構築するために必要な情報をここに保存するだけです｡

DART Packagesファイルについても同様です｡
で何か作業をするようなファイルではありません｡
これはFlutter SDKによって自動的に生成されるのでしょうか？

そして､ 最終的には､ このプロジェクトが必要とするいくつかのパッケージと､ いくつかの内部依存関係を管理するだけで､完全に自動管理されるようになります｡
消してはいけないが､ その中で働いてもいけない｡
この起動に失敗したIMLファイルは､ 名前にプロジェクト名を持つため､ 私たちが作業を行わないファイルでもあります｡

また､ Flutter SDKによって自動的に管理され､ このプロジェクトのいくつかの内部依存といくつかの設定を再び管理します｡と言えるし､ 私たちが変更するファイルでもない｡

さて､ ロックファイルにポップバックすることも､ これから作業する別のファイルであり､ YAMLファイルのポップアップを理解すれば､より明確になります｡
これは､ プロジェクトの依存関係をほとんど管理することができるファイルです｡

さて､ これはどういうことでしょうか｡

つまり､ プロジェクトが使用する他のサードパーティパッケージをここで設定することができます｡

また､ ここではその他の設定も可能です｡

例えば､ アプリケーションで使いたいフォントや画像などです｡

そして､ これらの機能をすべて使いこなすのです｡

私たちはサードパーティーのパッケージを使い､ フォントや画像を使用します｡ そこで､ このファイルの扱い方と､

新しいフォントや画像を追加するための変更方法を紹介します｡

そのすべてを順を追ってお見せします｡

基本的に､ ここにあるのはYAMLで書かれたコードです｡ これはテキストファイルを構造化するための特定のフォーマットで､

コードがどのように一緒に動作するかをインデントを使って表現します｡

例えば､ ここでは､ どの起動バージョンで動作するか､ どのアプリケーションのどのバージョンにするか､ その他どのサードパーティパッケージを使用するかなどを指定しています｡

ここにあるようなCupertinoのアイコンは､ 特定のiOSスタイルのアイコンをアプリケーションで使用できるようにするものです｡

そして､ このコースを通して､ サードパーティーのパッケージをここに追加していきます｡

つまり､ これは基本的に､ アプリケーションがどのように動作するか､ あるいはどのような外部依存性を持つかを設定するための競合ファイルなのです｡

とりあえず､ ここは何も変える必要はありません｡

最後のpubspec.lockは､ ここで作成した.yamlファイルを元に自動生成されたファイルです｡
そしてこれは単に､ あなたが持っているすべての依存関係の詳細を保持し､ flutterによって必要とされますが､ あなたが作業するファイルではありません｡
最終的には､ 先ほど申し上げたように､ 自動的に生成されることになります｡
YAMLファイルの中でのみ作業を行います｡
その場合､ 読み込んだファイルは自動的に生成されたRead Meファイルなので､ まあ無視すればいいのですが｡
これはプロジェクトに関する情報を保持するもので､ 開発者とプロジェクトを共有する場合､ 開発者に何らかの情報を与えたい場合は､ここで変更することができます｡

以上が､ すべてのフォルダとフォルトのウォークスルーのためのものでした｡

核となるのは､ libフォルダで作業し､ 時にはtop specやyamlファイルで作業し､ 基本的にすべてのファイルやフォルダを無視できるようにすることです｡

#####
そのために､ 現在 lib フォルダにある唯一の Dart ファイルを見てみましょう｡
main.dart｡ 今ある Dart ファイルはこれだけですし､最終的にアプリケーション全体を書き込むのはこのフォルダだと書きましたから､ このファイルが､ここで見ているような出力､ つまりこのアプリケーションを提供する役割を担っているはずで､実際にそうなっています｡ このファイルには､ このアプリケーションを画面にレンダリングするためのすべてのコードが含まれています｡

この緑色の線の最初に二重のスラッシュがあるものはすべてコメントで､
これは何かをするコードでもなく､ その後に起こることを説明するためにあるものです｡
結局､ これは本当に無駄のないファイルなんですね､
このファイルはどうなっているんだろう？
このファイルを書き換えて､ ゼロからアプリケーションを作りますが､その前に､ このようなFlutterアプリケーションがどのように動くのか､ Flutterが何をしてくれるのか､基本的な理解を得るために､ 簡単に説明したいと思います｡ 
Flutterはツールセットであると同時にフレームワークでもあり､Dart言語用のプログラミングフレームワークでもあり､ 最終的にFlutterアプリは開発者であるあなたがウィジェットを追加してUIを構築するアプリケーションです｡

ウィジェットはユーザーインターフェースの構成要素で､
右下のボタンはウィジェット､ テキストはウィジェット､
上部のappBarとその中のタイトルはウィジェットで､ このコードで見ることができます｡
このコードすべてを理解できなくても､ MyHomePageStateのこのbuildメソッドまで少しスクロールすれば､
今はまったく不明ですが､ スクロールすれば､ appBarやtextや別のtext､フローティングアクションボタンといったものを確認できます｡ たとえDartやFlutterをよく理解していなくても､ このフローティングアクションボタンが右下にあるフローティングボタンと関係しているということはおそらく理解できると思います｡

これらは自分たちで作ったものではありませんが､ Flutterフレームワークに組み込まれているウィジェットで､画面にテキストを表示したり､ ボタンを追加したりできます｡

さまざまな種類のボタン､ ドロップダウン､ 画像､ スクロールできるリストなど､ さまざまなウィジェットがあり､それがFlutterの仕組みです｡

これらの組み込みウィジェットを使ってユーザー・インターフェースを構築し､ これらのウィジェットの色を変更したり､

例えばここではテキストのサイズを変更したり､ また､ 組み込みウィジェットをグループ化して全く新しいカスタムウィジェットを構築し､

それをどこかに配置することもできます｡

例えば､ この小さいテキストと大きいテキストを組み合わせて､ アプリの他の場所でもこの組み合わせが必要な場合は､ 常にこの小さいテキストと大きいテキストを画面に印刷または描画するカスタム出力ウィジェットを持つことができます｡

DartやFlutterの仕組み､

ウィジェットの作成方法などについては､ コース中に詳しく説明していきますので､ ご安心ください｡

この開始コードでは､

ウィジェットで何かを行っているように見えることがすでにわかります｡

dartファイルを削除してください｡

さて､ なぜ私はそんなことをするのでしょう？

なぜなら､ 私はあなたと一緒にゼロから完全なアプリを作りたいからです｡

Dartを学ぶためだけでなく､

Flutterの仕組みを学ぶためにも､ 仕組みとコードを書く理由を理解することは非常に重要です｡

mainの中のコードをすべて削除してみましょう｡ アプリが自動的に再構築され､同期されるため､ クラッシュしてしまいます｡


#####
今度はメインで｡ アプリをゼロから作り直す前に､ まずプログラミングと

Dart の基礎について説明します｡

さて､ あなたがすでに経験豊富な開発者であれば､ JavaScriptやJava､ C#を使って仕事をしていれば､ これから説明することの多くをすでに知っていることでしょう｡

それでも､ Dartの詳細がいくつか出てきますので､ この講義をスキップせずに､

退屈であれば再生速度を上げることをお勧めします｡

もしあなたがプログラミングの初心者であったり､ プログラミングをしたことがないのであれば､ ぜひともついてきてください｡

DartPad はウェブベースのプレイグラウンドで､

Dart のコードを書いてブラウザで実行することができます｡

これはDartのコードで､ Flutterアプリではなく､

普通のDartのコードです｡ Dartはウェブ開発にも使えますが､

これはダミーのDartコードで､ 右側のコンソールに出力が表示されます｡

さて､ どうでしょう？

ここにある全体的なもの､ このメインとなるもの､ それはいわゆる機能です｡ 関数は､ これから学ぶプログラミング言語のほとんどにおいて重要な概念であり､

いつでも複数回実行できるコードスニペットです｡

ここの関数がmainと名付けられているのは､

ここの括弧の前にあるものが､ いわゆる関数名だからです｡

括弧自体は､ 定義したすべての関数に必ず必要で､ いわゆる関数への入力となる引数を受け取ることができます｡

この関数は単に引数を受け取らないので､ それにもかかわらず､ この括弧が関数になるために必要なのです｡

中括弧はいわゆる関数本体を囲んでいて､

この関数が呼び出されたときに実行されるコードです｡

ここでいうVoidとは､

いわゆる型のことです｡ Dartは型付き言語です｡ つまり､ Dartではすべてのものに型があり､

ここではこの関数が返すデータの型が型にあたります｡

この関数は何も返さないので､ 戻り値の型はvoid､

いわば空っぽです｡ これはiの型で､ iは数値､

いわゆる整数を保持しますが､ これについては後ほど説明します｡

これはmainという関数で､

引数を持たず､ 何も返さないので､ 戻り値の型はvoidであり､

これが関数本体です｡ 一般に､ 関数には好きな名前を付けることができますが､ mainはDartアプリケーションのエントリポイントであるため､

特別な名前になっているのです｡ Dartはアプリの起動時に自動的にmain関数を呼び出してくれるため､

Flutterアプリではmainを追加するとmainになります｡

dartファイルはFlutterが探す特別なファイルでもあり､

ここに括弧を付けてmainという関数を追加し､ その前にvoidを追加すると､ アプリが起動したときにDartとFlutterが自動的に実行する最初の関数になります｡

この関数には､ 基本的に画面に何かを表示するUIレンダリング作業を開始させるコードを記述する必要があります｡

つまり､ あれが関数で､ これが関数で､

mainは特殊な関数なんですね｡ これは特殊な関数なので､ おそらく他の関数も作ることができますよね｡

まず最初に､

関数内のコードを削除して､ main関数の上に新しい関数を追加してみましょう｡

これはDartや他の多くのプログラミング言語で使われている命名規則で､

覚えておくと他の開発者があなたのコードを見たときに簡単に理解することができます｡

さて､

先ほど申し上げたように､ 関数は引数を取ることができますので､ 入力です｡

今､ main関数は引数を取りませんでしたが､ addNumbersは2つの数字を足すコードを保持する関数なので､

今度は2つの数字を入力として受け取ることにします｡

この括弧の間に､ num1とnum2を追加します｡

関数名と同様に､

これらの名前もあなた次第で､ 好きな名前を付けることができます｡

中括弧で囲むことで､ この関数が呼び出されたときに実行されるコードが中括弧の間にあることを

Dart に知らせます｡

ここで､ アプリの起動時に最初に実行されるコードであるmain関数で､ この関数の名前を使用してDartに実行を指示します｡

つまり､ ここmainでaddNumbersを単純に名前で呼び､ ここで括弧をつける必要があるのだとしたら｡

この関数は引数を取らないので､

この括弧の間にaddNumbersに渡される具体的な値を追加してください｡

つまり､ num1とnum2には実際のデータがあり､ それを使って仕事をすることができますので､

ここでは1と2を足せばいいのです｡

もちろん､ この関数は今のところ何もしていません｡ ここでは1と2を指定して呼び出していますが､

これらの数字を本当に足すためのロジックは入っていません｡

ここでできることは､ num1 + num2 と呼んで､ それを足すことです｡

さて､ セミコロンを追加する必要があります｡ これはDartのもう一つの特徴で､ コード内のすべての式､

すべてのコード行について､ 最後にセミコロンを追加しなければなりません｡ 例外は関数の定義で､ この中括弧の後にセミコロンを追加する必要はありませんが､

関数内のすべてのコードについて追加します｡

一般に､

ブロックステートメントと呼ばれるものには､ 中括弧の間にコードがある場合､ 中括弧の後にセミコロンを付けず､

中括弧の間の式の後にのみセミコロンを付けます｡

ここでnum1 + num2として､ ここにセミコロンを追加しましたが､

今ある問題は､ ここで2つの数字を足していることで､

一般的にはうまくいきますが､ この演算の結果には何もしていません｡

これで､ 自動的に右のここに出力されるはずだと思うかもしれませんが､ さて､

どうでしょう｡

実行をクリックすると､

右側に空の出力が表示されます｡

はあ､ それではあまり参考にならないですね｡

プログラミングでは､ 何が起こるべきかを常に明確にする必要があります｡ なぜなら､ プログラミング言語（この場合はDart）は､

いかなる仮定も立てないからです｡

なぜここに印刷するのか､

そんなことは指示していない､ だからしないのだ｡

printは私たちが定義した関数ではなく､ Dartに組み込まれている関数です｡ num1

+ num2をprintでラップして､

実行を押すと､ 右側に3つ表示されます｡

例えば､

ここでは型を使っていませんが､ Dartは強く､

厳密に型付けされたプログラミング言語なのです｡

つまり､ 引数やこの関数が返すデータがどのタイプなのかを明確にする必要があり､ それに違反したコードを書くと､ Dartコンパイラが怒鳴る手助けをしてくれるものです｡

Dartに組み込まれたこの型は､

その名前が示すように型についてあまり多くを語らず､ 基本的にどんな値でも受け入れるため､ 適切なコードを書いているかどうかを確認するのにあまり役に立ちません｡

ですから､ Dartで作業するときは､ できればその動的な型を避け､ 明示的な型を割り当てるべきです｡ さて､ Dartにはいくつかの組み込み型があります｡

一般的なものはすべていわゆるオブジェクトで､ その中に複雑なロジックを持つデータ構造です｡ おそらく少なくとも､ 後でそのようなオブジェクトも作りますが､

ある特別なタイプのオブジェクトと言えるでしょう｡

例えばテキストがあり､

引用符を使うことでテキストを作成します｡

ここでhelloと入力してこれを印刷すると､ 引用符に注意してください｡ シングルクォートでもダブルクォートでも構いませんが､

混在させてはいけません｡ このコースではシングルクォートを使いますが､

これはいわゆる文字列データ型を作りますので､ これは文字列型の値であり､

テキストは単に文字列なのです｡

今､ 実行を押すと､ helloがプリントされているのがわかると思いますが､ これはここにプリントしているから､

ここに出力が表示されているのです｡ つまり､ 文字列は一つのデータ型である｡

数値には､ テキスト以外に､ いわゆる整数と､ 浮動小数点数､ 倍数というものがあります｡ 整数とは､ 29や43､ -10のように､

小数点以下の桁数がない数値のことです｡ フロートやダブルは､ 29のような小数点以下の数字を持つ数値です｡

99, -10. 56､ そんなところでしょうか｡ つまり､

この2つの数値は実際には整数になるのです｡

さて､ この関数では､ 整数のみで動作することを明確にしておく必要があり､

そのために各引数の前にintを付けています｡

これは､ num1とnum2がともに整数でなければならないことをDartに伝えている｡

今､ これを実行すると､ まだ動作しますが､

私は2を渡すだろう場合｡ 5または2｡ パラメータは基本的に引数の別の言葉です｡

もしこの関数が整数でしか動作しないとわかっているなら､

そのように定義すべきです｡ もしコードのどこかで誤ってdoubleで呼び出すと､

エラーが発生し､ Flutterアプリにコードを出荷する前にエラーが発生します｡

だからここでは､ エラーが発生することになる｡

つまり､ 整数値でしか呼び出さないようにコードを修正するか､

あるいは､ いやいや､ これは実は2倍値でも動くはずだ､ という場合は､ もちろん､ 2倍値を入力として受け入れるように変更して､

このコードを実行すると､ このコードは再び動き､ ここに2倍値を許容するから小数点以下の桁数を持つ2倍値を出力することになります｡

もちろん､ int型よりdouble型の方が柔軟性があるのだから､ いつもdouble型を使えばいいじゃないか､ と思うかもしれません｡

例えば､ 一度に1つずつしか増加しないカウンターの場合､

誤って小数点を含む無効な値でコードを実行しないように､

int型であることを明確にする必要があります｡

ただし､ ここでdoubleを使用すると､ 暗黙のうちにdoubleに変換されるため､

1を使って呼び出すこともできます｡

ですから､ doubleとintの両方を許容するのであれば､ ここでは本当にdoubleを使えばいいのです｡ このようにして､ 文字列と呼ばれるテキストと､

整数と倍数という数値について学びました｡

しかし､

この関数は何かを返すかもしれないし､ 返さないかもしれないので､

この関数がどんな種類のデータを返すかについての型情報を常に追加しておく必要があります｡

この関数は結果を表示するので､ 呼び出した場所には何も返しません｡ したがって､

ここでの正しい型はvoidです｡

VoidはDartの特殊な型であり､

基本的に何もないことを意味します｡

この関数は何も返しません｡

さて､ なぜそれが重要なのでしょうか？

例えば､ addNumbersの結果をこのように表示しようとすると､ この式の型がvoidなので表示できないというエラーが発生します｡

addNumbersは何も返さないので､ addNumbersを呼び出した結果を表示することはできません｡

確かに何かを表示しますが､ それは関数の内部で行われます｡

ここでは､ この関数が返すものを表示したいのですが､ この関数は何も返してくれません｡

しかし､ 実際にそうなるようにすることは可能です｡ ここにプリントする代わりに､ これをコメントアウトしてみましょう｡

スラッシュを2つ追加すれば､ このコードは考慮されません｡ ところで､

これはよくあるパターンですが､ 実行したくないが後で使いたいかもしれないコードをコメントアウトします｡ つまり､ 削除するのではなく､ 単にコメントアウトして､

まだそこにあるが実行しないようにします｡

これはDartに､

関数を呼び出した場所に何かを返すことを指示するキーワードです｡

つまり､ num1 + num2 を返すと､ addNumbers

の結果が表示され､ addNumbers が返す結果が表示されて､ 2つの数値が返されることになるので､

これは有効なコードです｡

今これを実行すると､ この式の戻り値の型がvoidなので値を返せないというエラーが出ますが､

これもまた良いことです｡

addNumbersは何も返さない､ 何も返さない､ と定義しておきながら､ ここでは何かを返しているのです｡

ここで､ 解決策は戻り値の型を変更することです｡ ここでは､

2つのdoubleを足すので､ 常にdoubleを返しますので､ doubleに変更します｡

この関数を呼び出して実行すると､ エラーは発生せず､

3が表示されます｡ 6は､ 代わりにこちら｡

文字列と数値という核となる型があり､ 整数と倍数､

そして他のいくつかの型についてもこのコースで学びます｡ これはDartの核となる概念であり､ 関数がDartの核となる概念であるのと同様に､

addNumbersを好きなだけ呼び出せるようになります｡

なぜなら､ コードを追加するためのロジックを一度書けば､

何度でも異なる入力で呼び出すことができるからです｡ したがって､

関数はプログラミングやDartにおいて本当に重要な概念です｡

############
プログラミングの基本である関数や型､ あるいは重要な型について一通り見てきましたが､ プログラミングにはもっと多くの機能があり､

本題に戻る前に理解する必要がある機能が2つあります｡

dartファイルです｡

第一の特徴は､ 変数の特徴や考え方です｡

これまで私がここでいつもやっていたのは､ addNumbersの結果をすぐに表示することでした｡

もちろん､ これは簡単なダミーコードなので､ ここで意味をなすものではありませんが､

基本的にはこれで何が得られるかを確認したいだけです｡

しかし､ 実際には､ 計算結果やユーザー入力の結果をどこかに保存しておき､ 後で使えるようにしたい､

というプログラムを書くことが多い｡

ここでいう保存とは､ データベースではなく､ メモリに保存するという意味です｡ なぜなら､

同じコードの中で､ 数行後に必要になるからです｡

つまり､ ファイルに書き込んだり､ データベースに保存したりするのではなく､

このコードが実行されたときに､ それを取り出して､

たとえば数行先で使えるように､ メモリに保存しておきたいのです｡ いわゆる変数の助けを借りて､ データを保存することができます｡

ここで､

firstResultをすぐに出力するのではなく､ 変数に格納することにしましょう｡

firstResultのように好きな名前をつけて変数を作成します｡ ここでの命名規則は関数と同じで､

キャメルケース､ 小文字の開始文字､ そして1つの単語のみを使用し､ 単語の中のすべての単語は大文字で開始されます｡

これがfirstResultで､ このいわゆる変数に等号で値を代入しているわけです｡

変数と呼ばれるのは､ そこにあるデータを変更できるようにするためです｡ ここでは､

addNumbersの結果をfirstResultに格納していますが､ これを再利用して､ その結果もfirstResultに格納することが可能です｡

つまり､ 1行目以降は､ 1と2に対するaddNumbersの結果です｡ 6はここに格納されるでしょう､ ここの2行目の行の後､

1と1とのaddNumbersの結果はここに格納されるでしょう､

そしてfirstResult､ だからここのこの行の結果はドロップされるでしょう､ 我々は今その結果をfirstResult変数に格納することになるでしょう｡

しかし､ ここで構文エラーが発生し､ Dartがこれを理解していないことを意味します｡

これはほぼ正しい構文ですが､ Dartにこれが変数であることを伝えるには､ その変数を初めて作成するときに､

ここにvarキーワードを追加する必要があります｡ この行では､ 同じ名前の同じ変数をもう一度使いますが､

導入するときに､ varキーワードを追加して､ Dartにこれは変数であることを伝える必要があります｡

時には､ コードを読みやすくするために変数を使い､ 複数の行に分けることもあります｡

また､ 最初に実行する必要がある他のコードを間に挟み､

後で firstResult を使いたい場合もあります｡

他の計算と組み合わせて､ プラス1するようなことも可能かもしれませんね｡

firstResultはaddNumbersが返した値を保持するだけで､

この場合の数値はdoubleなので､ 他のdoubleと同じように何でもできるのです｡

つまり､ firstResultにはaddNumbersの結果である1と1が格納されているので2であり､ これに1を加えて2

+ 1となり､ その結果をプリントしているので､

ここに3が表示されるのです｡ 変数はDartの中核となる機能で､ このコースを通してたくさん目にすることになります｡

この構文ではvarを使用して作成していますが､ この変数が最終的に保持するデータの型を追加して作成することもできます｡

ですから､ この場合は double firstResult と書くこともできます｡

しかし､ Dartには型推論という機能があり､ これは右側にある値からここに格納するデータの型を推論することができるということです｡

ここでは､

doubleを返すaddNumbersを呼び出し､ 常にdoubleを返しているので､

DartはfirstResultがdoubleを保持すると推測することができ､

そのことをDartに伝える必要はありません｡ このように､ 初期値を代入せずに変数を作成すると､

また別の話になります｡

変数が存在するけれども､ 初期化されていないということもありえます｡

このような場合､

最終的にどのようなデータがこの変数に入るのかをDartに伝えるのが良い方法です｡

したがって､ varの代わりにここの型､ この場合ではdoubleを使用します｡

これを実行すると､ 前と同じ出力が表示されますが､ ここでは少し違うものを作成し､

varの代わりにdoubleを使用しています｡ これが重要な特徴の一つですが､ もう一つの重要な特徴は､ Dartがいわゆるオブジェクト指向のプログラミング言語であることです｡

Dartはすべてオブジェクトだと言いましたが､

この数字も､ この数字も､ オブジェクトです｡ 数字と言えばその通りなのですが､ 数字はあくまで物体です｡

さて､ オブジェクトとは何でしょうか？

Dartでは基本的にすべてがデータ構造で､ その中にさまざまな情報が含まれています｡

ここで､ 情報はもちろん1つですが､ Dartが内部で使用する他のメタデータがあると言えます｡

では､ なぜ実際にデータ構造をオブジェクトで表現するようになったのでしょうか｡

まあ､ それは単純に現実世界との関係なんですけどね｡

現実の世界を考えてみると､ そこでもモノを扱っていますよね｡

車を持っていて､ その車を運転できるとか､ 車の座席数が決まっているとか､ 馬力が決まっているとか｡

そこで､ 現実の世界をオブジェクトで表現し､ その考え方を開発､ プログラミングに持ち込むことで､ より現実の世界に近づけようというのが､

このアイデアの狙いです｡

例えば､ モバイルアプリにはボタンがありますが､

このように考えると､ ボタンはもちろん有効なオブジェクトになります｡

これがオブジェクトと呼ぶ理由であり､ オブジェクトを使うという考え方はどこから来たのか､

なぜオブジェクトと呼ぶデータ構造に物事をまとめるのか､

それは単に実世界から来たもので､ プログラムについて考えたり推論したりするのに役立つはずです｡

テキストや数値だけでなく､ より複雑なデータ構造をコードで表現したい場合もありますから､

独自のオブジェクトを作成することも可能です｡

例えば､ 名前と年齢を持つ人がいるとします｡

もちろん､ ここでString nameという変数を作ってもいい｡

Stringの場合､

DartにString型であることを伝える方法です｡

doubleと違って大文字で始まるのはご愛嬌｡

つまり､ 文字列の名前と､ 例えばint型の年齢を持つことが可能で､

そこに値を格納することができ､ 開発者としては､ この2つが関連していることはもちろん明らかです｡

しかし､ 他の開発者にとってはそうではないかもしれませんし､

たとえ明確であっても､ 常にこの2つの別々の変数を扱わなければならないのは少し煩わしいものです｡

オブジェクトを作成するには､

まず最初に､ そのオブジェクトがどのように見えるべきかをDartに伝えるためのブループリントが必要です｡

これは､

他のプログラミング言語でも見られるDartの中核的な機能であるクラスを使って行われます｡ クラスは､ オブジェクトの青写真を定義することができます｡ クラスには名前が必要で､ それはperson（人）かもしれません｡

ここでは､ 小文字で始めるのではなく､ 大文字で始めるという命名規則になっています｡

そして､ 関数と同じように中括弧でクラス本体を追加します｡

さて､ これはどういうことでしょうか｡

例えば､ ここに変数を追加することができます｡ 必要であれば､

変数名と年齢を追加することができます｡

さて､ クラス内に変数がある場合､ これはプロパティと呼ばれることもあります｡

そのため､ このプロパティを変更したときに､ クラスの中の変数を変更したことがわかるように､

特別な名前を付けています｡ 一方､ 関数内の変数は変数と呼ばれ､ プロパティと言えば､

関数内の変数ではなく､ クラス内の変数を指していることがわかるように､

このような異なる用語が使われているのです｡

関数内の通常の変数と同じように､ 値を代入する場合､ ここでは Max

と 30 を使っていますが､ 実際にはここでも string や

int ではなく､ var を使うべきです｡

ここでstringとintを使っているのは､ 後で初期化しないように変更するからですが､

もしこのままにしておくなら､ 初期値でプロパティを初期化するつもりなら､ 型を繰り返す代わりに､

ここでもvarを使うべきでしょう｡ 型を繰り返してもエラーにはなりませんが､

varを使用してDartの型推論に任せるのがベターな方法と考えられます｡

そして今､ メイン関数の中で､ このような人が必要な場合､ p1など好きな名前の変数を作り､ このクラスの新しいインスタンスを作ります｡

クラスは単なる青写真で､ クラスのインスタンスは､ このように人を呼び出すことで作業する具体的なオブジェクトなのです｡

他のプログラミングの経験があれば､ newキーワードを前につけて使うことに慣れたかもしれません｡

newは､ 他のプログラミング言語では､ 自分のクラスに基づいて新しいオブジェクトを作成するために必要なものです｡

これはDart 2でも使えますが､ このコースで使用するDart 2では不要になったので､

このように人を呼びます｡

つまり､ personを関数として実行し､ このクラスをインスタンス化してp1に格納します｡ したがって､

p1をここに表示してこのコードを実行すると､ 実際にpersonのインスタンスがここに表示されます｡

さて､

このクラスでは､ ここに格納されているデータにドット記法で便利にアクセスできるようになりましたので､ p1と入力します｡ そして､ 名前とか年齢とか､ Dartのすべてのクラスが持っている､

Dartが自動的に追加する他のいくつかのものを選択することができます｡

を実行すると､ ここに30と表示されます｡

これで､ そのデータをグループ化し､ 再度personを呼び出すだけで､ 新しいpersonを作成することができます｡

また､ p2にアクセスすることで､ その人のデータを変更することができます｡ という名前を付けて､ それを例えばManuに変更し､

今度はp2を印刷します｡ の名前を書いて､ p1をプリントします｡ というのは､ 最初の人は名前を変えていないので､

デフォルトのままですが､ 2番目の人は名前を変えたので､ ここで名前を変えてManuにし､下の方はManuとプリントしています｡
このように､クラスは多くのプログラミング言語において重要な機能であり､ Dartにおいても同様です｡ このコースを通して､ クラスやDartについてもっと学びます｡

1時間に及ぶDartの紹介で皆さんを退屈させたくないので､

Flutterを学びながらDartを学ぶ方が面白いと思います｡

dartファイルを開き､ そこで何が起こっているのかを理解する｡

#########
で､ メインに戻る｡ dartファイルでは､ そのmain関数があります｡ ご存知のように､ これは関数で､ 何も返さず､何も引数を取らず､ そして今､関数本体にも何もありません｡

さて､ 学習した通り､ mainはFlutterやDartではmainの中にあるため､ アプリ起動時に自動的に実行される関数です｡

dart ファイルの名前を変更してはいけません｡

さて､ ここで実際に画面に何かを表示させるコードを追加する必要があります｡

そのためには､ 画面上では基本的にウィジェットの束を見るということを理解することが重要です｡ 
Flutterはウィジェットに関するもので､これを理解することがとても重要なのです｡
ウィジェットは画面上に表示されるUIの構成要素で､アプリバー､ 画像､ リスト項目､ そしてここにあるように､ ウィジェットは他のウィジェットを含むことがよくあります｡

つまり､ Flutterのアプリは､ 前に述べたウィジェットのツリーとして構成され､ アプリ全体であるルートウィジェットを持ち､ その中に他のウィジェットがあり､さらにその中に他のウィジェットやページ全体もあるかもしれないので､画面上のページ上の全てのウィジェットを保持する全体がFlutterのウィジェットなのです｡

Flutterではすべてがウィジェットで､アプリ全体がウィジェットなので､ おそらくこのようなアプリウィジェットを作成する必要があり､ そのウィジェットは画面上で何かを見るために他のウィジェットを持つことになりますが､それは100%正しいです｡ このようなウィジェットを作成するには､ クラスを作成する必要があります｡ ウィジェットは､いわば特殊なタイプのオブジェクトであり､オブジェクトを作成するためにはクラスが必要であることを学びましたね｡

パスカルケースと呼ばれる命名規則に従って､大文字で始まり､ その中のすべての単語も大文字で始まるようにします｡

具体的な名称は､MyApp､ MyCoolAppなど､ お好みでどうぞ｡ これはクラスですが､ 想像できるかもしれませんが､本当にスクリーン上で見ることができるウィジェットを作るのは､ それほど簡単なことではありません｡
ありがたいことに､ このロジックを自分で書く必要はありません｡ Flutterが裏ですべてやってくれるので､このクラスでは継承という機能を使っています｡

つまり､ ベースクラスの上に構築し､ そのベースクラスの機能をすべて取得し､ そこに新しい機能だけを追加していくものです｡

中括弧の前のクラス名の後に extends キーワードを追加することで､ このクラスが他のクラスをベースにしていることを Dartに知らせ､ 一度に一つのクラスしか拡張できないようにすることができます｡

さてここで拡張したいクラスは､ 私たちが書くクラスではなく､ Flutterが提供するクラスです｡

もちろん､ プロジェクト全体ではlib フォルダにある Dart
ファイルは1 つだけです｡

今､ そのフレームワークのファイルは､ そのプロジェクトに保存されていません｡ 代わりに､あなたのマシンのどこか他の場所､ 通常はユーザーフォルダーのどこかに保存されていますが､ 接続はpubspecのこのエントリの助けを借りて確立されているため､これらのファイルからインポートすることができます｡

yamlファイルです｡だから今､ メインで｡ この場合､ Flutter フレームワークのファイルにアクセスしたいことをDart に伝えることができ､ そのファイルはここで拡張したいクラスを提供してくれます｡

このキーワードは､ Dartに「このファイルにはないが､他のファイルにある機能が欲しい」と伝えるものです｡

自分のファイルを指定することもできますが､プロジェクトの一部であるサードパーティパッケージを指定することもできます｡

package:とパッケージの名前､ この場合はFlutter､ そして多くのパッケージはこのパッケージを構成する多くのファイルを持っていることを追加することで行います｡

つまり､ここにスラッシュを付けて､ 具体的なファイル（この場合はmaterial）を指し示すのです｡

ダートこれはFlutterフレームワークが公開しているファイルの1つで､マテリアルテーマに従った多くの組み込みウィジェットがあります｡ 後ほど､ あなたのアプリをiOSで美しく見せる方法も学びますが､マテリアルテーマはiOSでも使えますし､ これらのプレステージの高いマテリアルルックのウィジェット以外にも､ マテリアルはあります｡

dartファイルには､ 独自のウィジェットを作成するための基本クラスもあり､ それがステートレスウィジェットクラスです｡

ここでstateless widgetを拡張することで､ このクラスはFlutterでwidgetとして使えるクラスになります｡

しかし､ 今度はここにStatelessWidgetの正しい実装がないという新たなエラーが発生した｡

を構築します｡
さて､ これはどういうことでしょうか｡ 今すぐ ビルドシグナルは､これがクラスの一部であるプロパティ､ つまり変数､ またはクラスの一部である関数のようであることを示します｡

これまで見てきませんでしたが､ 変数の他に､ クラスの中に関数を持つこともできます｡

ここで､ クラスの中の変数はプロパティと呼ばれ､

クラスの中の関数はメソッドと呼ばれることになる｡

そこで､ ここに特別なメソッドを追加する必要があるのですが､

では､ それがプロパティではなくメソッドであることをどのように確認すればよいのでしょうか｡

ただ､ 暗記しなければならない､ 数少ないものなんです｡

これはメソッドなので､ 事実上関数です｡

ここに括弧を追加して､ その関数の本体をマークするために中括弧を追加しなければなりません｡

この関数は引数を取ることができます｡ この上にカーソルを置いてエラーを読むと､

このメソッドはビルドメソッドの有効なオーバーライドではないことがわかります｡

これは特別なタイプのオブジェクトで､buildメソッドに自動的に渡されます｡

このメソッドを呼び出すことはないので､ Flutterは画面に何かを描く必要があるときに呼び出します｡

型はビルドコンテキストで､材料も定義されているエンドクラスである｡ ダーツがあるからこそ､ ここで使うことができるのです｡

つまり､ ビルドコンテキストはFlutterがマテリアルで提供する特別なオブジェクトタイプなのです｡ dartファイルから､ このコンテキストオブジェクトはそのタイプであり､

Flutterによって自動的に取得されます｡ なぜならFlutterではアプリ全体をウィジェットとして扱うので､

アプリを構築しようとしているのです｡

ビルドコンテキストと同じように､ ウィジェットも最終的にはクラスとなり､

すべてのクラスは自動的にマテリアルで提供される型となります｡ ダート

ここで､ このようなウィジェットを

MyApp の内部で返す必要がありますが､ そこで返すべき特別なウィジェットがあります｡

dartはFlutterチームが提供するウィジェットで､

ウィジェットの組み合わせをレンダリング可能な実際のアプリにするための基本的なセットアップを行い､ 舞台裏で多くの力仕事を行います｡

また､

MaterialAppはいくつかの引数を取ります｡ 見ての通りかなり長いリストで､ これらの引数はすべていわゆる名前付き引数です｡

今までのところ､ 位置引数のようなものしか見ていません｡

つまり､ buildメソッドはcontextという引数を取るので､

最後に名前を付けてこのように受け取ります｡

 MaterialAppはいわゆる名前付き引数を使うので､
順番にデータを渡すわけではありませんが､
設定可能な引数がたくさんあり､ 最終的にはすべてオプションなので､
引数の名前をターゲットにして､ 当面はhome引数だけが必要です｡

Homeは基本的に､

このアプリ全体が画面にマウントされたときにFlutterが画面に持ってくるコアウィジェットで､

ここではFlutterに組み込まれた別のウィジェットであるテキストウィジェットを使用することができます｡

Textは文字列を取り､ 入力としてシングルクォートまたはダブルクォートで作成できるデータ型について学びましたので､

ここではHelloと表示することができます｡

これで､ Materialが提供するMaterialAppウィジェットができました｡ この名前付き引数は､ このコースを通して使用するものです｡

また､ 名前付き引数を取る独自の関数も作成しますので､

より明確になります｡ さて､ MaterialAppは関数なのかクラスなのか､ という疑問をお持ちの方のために余談ですが､

MaterialAppはクラスでありながら､ コンストラクタという機能を使ってデータを渡すことができます｡

とりあえず､ これはアプリとして扱えるものを作成するためのコードであることを受け入れましょう｡

なぜなら､ MaterialAppは舞台裏で多くの重い仕事をこなしており､ 何らかのコードを出力するはずだからです｡

あとは､ このクラスでmain関数を配線するだけです｡

##########
Udemy
Flutter & Dart - The Complete Guide [2023 Edition]
レクチャーのサムネイル
0:10 / 3:25
トランスクリプション
この2つを繋いで画面に表示するには､ mainで､ ウィジェットを受け取って画面に描画するコードを実行する必要がありますが､

そのためにmaterialが提供する別の関数があります｡

dartと呼ばれるもので､ これはrunAppと呼ばれています｡ さて､

runAppは通常の関数ですが､ 私たちが書いたものではなく､ Flutterチームが書いたもので､ その資料で公開されています｡

dartファイルです｡

だから､ お分かりだと思いますが､ その素材を取り込むこと｡ dart ファイルは､ アプリを構築するために必要な多くのコア機能を解放してくれます｡

runAppはその名の通り､

AndroidアプリやiOSアプリが起動したらFlutterアプリを実行します｡ つまり､ ウィジェットツリーを使って､ そのツリーに基づいた何かを画面に描画しようとします｡

しかし､

そのためには､ runApp にコアウィジェットが何であるかを伝える必要があり､ それはもちろん､ MyApp ウィジェットです｡

ここでMyAppを渡し､ 括弧を付けて関数のように実行します｡ この括弧は重要で､

さもなければ型として使うことになりますが､ これは型を必要とせず､

具象オブジェクトであり､ 括弧を付けてクラスに基づいてオブジェクトをインスタンス化するのです｡

それは､ 私たちがパーソンを作るときにやったことでもありますね｡

runApp はアプリを実行し､ ウィジェットを受け取って実行します｡

正確には､ ウィジェットに対して行うことは､ もちろんウィジェットを作成することです｡

runAppはこれを受け取り､

buildメソッドを呼び出します｡ これが最終的な処理で､ buildが初めて起動され､

アプリの構築が続き､ 画面に何かが表示されます｡ したがって､ このファイルを保存してデバッグに進み､

デバッグせずに再び起動すると､ エミュレータに戻すことができるはずです｡ このアプリケーションは非常に基本的で醜く､ どこかで「こんにちは」を出力します｡

そのため､ 私たちは基本的にユーザーインターフェイスとそこに表示されるものだけを気にしています｡

個々のピクセルのレンダリングや､

アプリのライフサイクルの管理､ アプリの起動､ Android端末のホーム画面でのイベントのリスニングなど､ 一切行う必要がなく､ ここで行うのは､ 画面に表示されるものを制御することです｡

これで､ Androidエミュレータ用のapkに組み込まれ､ 完了すると､ これが表示されます｡

これは期待された結果であり､

スタイリングも定義していませんし､

より美しいレンダリングにつながるものも定義していませんが､ ここではhelloが表示されています｡

つまり､ この基本的なコードが動作し､ ステートレスウィジェットによって提供されるいくつかの追加機能を持つ通常のクラスである独自のウィジェットクラスを作成し､

これをメイン関数が受け入れて runApp の助けを借りてアプリを実行したことが証明されています｡

###
このアプリをさらに深く掘り下げ､ より美しいものを作り上げる前に､

一歩下がってDartの話に戻りましょう｡

ひとつは､ MaterialAppとテキストに話を戻します｡

これらは関数ではなくクラスであると言いましたが､ データを渡したり､ hello文字列をtextに渡したり､

MaterialAppのホームコロンのような奇妙なものも持っています｡

DartPadで始めた小さなDartのサンプルに戻りましょう｡

ここにはpersonもあり､ personはいくつかのデフォルト値を持っています｡

例えば､ ユーザーがサインアップできるアプリケーションを作成する場合､

なぜ平均的なユーザーの名前がMaxであると仮定するのか､ それは全く意味を成しません｡

そのため､ 初期値を持たない設定にしたい場合もありますが､ その代わりにこのクラスが作成されたときに､

括弧の間に初期値を渡すことができます｡ つまり､

ここではMaxと30､ Manuと31があり､ 下の名前を上書きする必要はありません｡

それはいいのですが､ 今はサポートされていないので､ このクラスにいわゆるコンストラクタを追加することでサポートできます｡

コンストラクタはクラス内の関数なので､

メソッドと呼ぶこともできます｡

クラス内の関数もメソッドなので､ 名前が違うだけです｡

クラスの名前､ この場合はpersonのように繰り返してコンストラクタを追加します｡ 他のプログラミング言語では､ 例えばコンストラクタと書きますが､

Dartでは本当に名前が繰り返されるだけなんです｡

通常の関数と同じように括弧を付け､ 中括弧を付けて､ このクラスが作成されたときに実行されるべきコードを保持します｡

ここで､ nameやageのような引数､ あるいはinput nameやinput

ageを受け付けると､ 上で選んだ名前との混乱を避けることができますが､

Dartにはスコープという機能があるので､ 同じ名前を使うこともできます｡

つまり､ ここで挙げたのと同じ名前を引数に与えた場合､ これを上書きしたりせず､

単に人の中に新しい変数を作成します｡

しかし､ ここでは､ 混乱しないように､

異なる名前を選びました｡ コンストラクタ本体の内部では､ nameと入力して入力名を値として代入するだけで､

この上の名前を参照できますし､ 年齢も同じです｡

ところで､ 同じ名前､ たとえばここにageがあるとすると､

Dartはコンストラクタのボディでageを使うときに､ 上のageを意味するのか､

それとも下のageを意味するのか､ もちろんわからないでしょう｡

age

を指定すると､ Dart に「ここではクラスレベルの age 変数を参照したいが､ これを指定しない場合は関数またはコンストラクタレベルの変数を参照したい」と伝えることができます｡

このコードでは､ nameについても同様に､

2つの異なるオプションを表示することができます｡

これはコンストラクタに渡す文字列を受け取る機能で､

これを使用して何かを出力します｡

この構文を使う以外に､ 名前付き引数を使うこともできます｡ これは､

中括弧で囲むだけです｡

つまり､ これらの引数はすべてオプションであり､ 値を指定しなくても動作するようなコードを書くべきであり､

データを作成する際には名前を指定してターゲットにする必要があります｡

つまり､ inputName: や age: のように､ そのオブジェクトをベースにインスタンスを生成する際に､

引数の名前を繰り返すことで､ 引数の名前をターゲットにすることができます｡

また､ その名前付き引数の概念は､ コンストラクタだけでなく､ 通常の関数でも利用可能である｡

今､ これを繰り返すと､

やはりうまくいく｡

さて､ なぜ名前付き引数を使うのでしょうか？

特に､ コンストラクタや関数など､ 多くの引数を取る場合に便利です｡ というのも､ 通常の位置指定引数､ つまり名前のない引数の場合､

どの引数をどの位置に入れるか､ つまり名前が第1引数､ 年齢が第2引数というように覚えておかなければならないからです｡

引数が2つのコンストラクタなら可能ですが､

引数が10個になるともっと大変になります｡ 名前付き引数を使うことで､ 単純に名前を使って割り当てることができますし､

やろうと思えばここで順番を混ぜることもできます｡

ここでは､ まず年齢を代入し､ 次に名前を代入することができます｡

なぜなら､ 名前をターゲットにしているので､ 引数の名前で､ したがって､

順序は重要ではありません｡ さて､ 名前付き引数はすべて自動的にオプションになると書きましたので､

引数リストのここに等号を付けてデフォルト値を定義することもできます｡

もちろん､

コードが壊れるのを避けるために､ 特別なアノテーション､

@requiredアノテーションを追加することもできます｡

これで､ オプションの名前付き引数を必須引数に戻したわけです｡

余談ですが､ requiredはDartに組み込まれた機能ではないので､ ここではDartは@requiredの意味を理解していないというエラーが出ますが､Flutterには組み込まれる予定なので､ これを使えるようになります｡

さて､最後にもう一つ､ ここで@requiredを削除すると､

重要なのでもう一つ､ デフォルト値を再度追加してみましょう｡

あるデータを取得し､

それをクラスの変数に代入する､ というのはよくあることなので､ わざわざコードを書かなくても､ コンストラクタ本体を削除し､

その後にセミコロンを追加して､ 変数名やプロパティ名をここで使うようにします｡

そして､これで再び動作するようになりました｡ もちろん､ コンストラクタのために余分な関数本体を書くよりも短時間で済みます｡


######
このアプリケーションにつながる最初のコード行は､ 明らかにアプリストアに出荷されるような種類のアプリケーションではありません｡

しかし､

もう少し美しいアプリケーションを作るために深く潜る前に､ これまで学んだことを簡単にまとめておきましょう｡

そう､ これは繰り返しですが､ この仕組みと私たちが行ったことを理解することはとても大切で重要なことです｡

だから､ このメインがあるんです｡ dartファイルにmain関数があり､ このmain関数がアプリの起動時に自動的に実行されることが重要です｡

その中で､ Flutterチームがマテリアルで提供している関数であるrun appを呼び出します｡ dart

パッケージをインポートしています｡

Flutterのパッケージをインポートすることができ､ そこに､ pubspecで接続されているので､ 材料ファイルをインポートすることができます｡

yamlファイルです｡ このコースの後半では､

他のサードパーティ製パッケージも追加して､ 自分たちで構築する必要のない機能をさらに追加する予定です｡

これは重要なルールで､ Flutterのすべてのウィジェットはステートレスなウィジェットかステートフルなウィジェットを継承する必要があり､

2つのベースウィジェットクラスのいずれかを継承する必要があります｡

runAppはFlutterにプロンプトを出したり､ Flutterに画面に何かを描くように指示したりするので､

Flutterはいろいろなことをしますが､ runAppに渡したウィジェットのビルドメソッドも呼び出します｡

build メソッドは常に画面に描画される新しいウィジェットを返す責任があります｡

したがって､ ある時点で Flutter に同梱されている基本ウィジェットを返すことになります｡

もちろん､ それ以上のこともやっていますが､ 一応､ そういう考え方もできるわけです｡

ウィジェットはウィジェットを返す必要があるので､

ある時点で､ これらの基本ウィジェットを返すことになります｡

最終的には､ これらの基本ウィジェットでユーザーインターフェイス全体を構築することになります｡

さて､ ビルドメソッドはこのコンテキストの引数を回す｡ Flutterがbuildを呼んでくれたので､ contextの値を提供するのはFlutterの仕事なので､

それを気にする必要はありません｡

コンテキストはビルドコンテキストタイプのオブジェクトで､

Flutterが提供するビルドコンテキストブループリントを使用し､ このウィジェット､ ウィジェットツリーでの位置､

アプリケーション全体に関するメタデータを保持します｡

ここで起きているのは､ このようなことです｡ さて､ MyAppウィジェットビルドメソッドでは､ MaterialAppを返していますが､

これはウィジェットで､ Flutterチームが提供するウィジェットです｡

homeという名前付きの引数を使い､ この名前付きの引数の値として､ さらに別のウィジェット､ Flutterパッケージが提供するテキストウィジェットを渡します｡

これはいわゆる位置引数を使っています｡

つまり､ textとhelloはどちらも引数で､ textはホーム引数のMaterialAppへの引数､ helloはテキストウィジェットへの引数です｡

すべてのウィジェットは単なるDartクラスで､ 最終的にはビルドメソッドを持っています｡

これはここで起こっていることです｡

クラス名の後に括弧をつけることで､ ここでやっているように､ そのクラスをインスタンス化して､

そのクラスの具象オブジェクトを作成しているのです｡

もちろん､ 名前付き引数や変数､ メソッドなど､ それ以上のものがありますが､

私たちはそのすべてを段階的に学び､ コースの前では前面に出しません｡

むしろ､ 今少し深く潜って､ 画面上にもっと美しいものが見えるようにしましょう｡

しかし､ その前に､ このビルドメソッドに追加したい重要なアノテーションがあります｡

技術的には､ この機能は必要ありません｡

これはいわゆるデコレーターで､ おそらくお察しの通り､ DartやFlutterでも提供されているデコレーターです｡

したがってoverrideは実際にはDartが提供しており､ Flutterは提供していませんが､ 先ほど紹介した@requiredなどのデコレーターは他にもあり､

Flutterが提供しているでしょう｡

さて､ このデコレーターというのは何をするものなのでしょうか｡

これなしでも動きましたが｡

はい､ なくても動作します｡

これは､ コードを少しわかりやすく､ 少しすっきりさせるためにあります｡

これは､ ステートレスウィジェットが提供するビルドメソッドを意図的にオーバーライドしていることを明確にするものです｡

もし､ 拡張するクラスにも存在するメソッドを提供する場合は､

@Override を追加して､ 既存のメソッドを上書きするのではなく､

意図的に上書きしていることを明確にする必要があります｡

エラーではなく､ 意図的にやったことだとはっきりさせたいのでしょう｡ これは小さな､ スタイル上のことですが､ コース全体を通して見られることなので､

ここで触れておきたいと思います｡

そしてもうひとつ､

たとえばFlutterのアプリを新規に作成するときに､ 目にすることがあります｡ void mainがあり､

括弧があり､ 中括弧の代わりに等号と大号があり､

矢印のようなものがあります｡

中括弧の間にあったものが､ 中括弧のない矢印の後に来るようになりました｡

これも有効な Dart

構文で､ 式が 1 つだけ､ つまり関数内のコードが 1 行だけの関数の略記です｡ 中括弧を省略して､

ここに矢印を追加すると､ Dart に対して､ これは式を 1 つだけ持つ関数で､ ここに式があります､ 実行してください､ 他に何もありません､

ここに式の結果も自動的に返されます｡

ここで､ runAppは何も返さないので､ 関数全体も何も返しませんが､

もしrunAppが値を返すなら､ この関数も自動的に返されることになります｡

この機能は､ 1つの式を持つ関数で､ その式を実行したい場合に使用できます｡

これはその代替構文であり､ この構文が何をするものなのかがわかるようにするためのものです｡

でも､ それを踏まえて､ 今度はもう少し美しいアプリが画面に表示されるようにしましょう｡

####
より美しいアプリを作るには､ 背景を白にして､ この赤っぽいテキストと黄色の二重下線を付けないのが良いスタートでしょう｡

これはMaterialAppでテキストウィジェットを出力しているためで､ 画面に何かを表示するには十分ですが､

モバイルアプリのデフォルトスタイルはありません｡

Flutterの場合､ 背景やappBarはすべて手動で設定する必要があるからです｡

FlutterはUI全体を制御し､ 画面上のすべてのピクセルは最終的にFlutterフレームワークによってFlutterアプリが制御されることを念頭に置いてください｡

既存のモバイルアプリにウィジェットやコンポーネントを組み込むのではなく､ アプリ全体をコントロールするため､

背景色はどうするのか､ appBarはあるのか､ など細部にわたって明確な指示を出す必要があるのです｡

そのために､ 小さなヘルパーウィジェットを使用することができます｡

そして､ 足場は､ 材料に焼き付けられるもう一つのウィジェットです｡ ダート

scaffoldは､ アプリのベースとなるページデザインを作成する役割を担っています｡

Scaffold

にはいくつかの名前付き引数があり､ コントロール・スペースを押すと､ IDE で自動補完が行われ､

サポートされている名前付き引数のリストが表示されます｡

ここで､ appBarを追加し､ 再びappBarにカーソルを合わせると､ 好みのサイズのウィジェットを取ることができます｡

さて､ 好みのサイズのウィジェットとは何でしょう？

これは特殊なウィジェットで､ 自分で作ることもできますが､ appBarはどのアプリケーションでも典型的で特殊なものなので､

appBarという名前のビルド済みのウィジェットを渡すだけでいいのです｡

appBar もまた､ material が提供するウィジェットです｡ ここではクラスをインスタンス化していますが､

これはステートレスまたはステートフルなウィジェットを拡張するクラスであり､ appBar では再びいくつかの設定を行います｡

ここで､

カーソルを括弧の中に置いたままコントロールスペースを押すと､

ここに何を渡すことができるかという説明が表示され､ ここに束を渡すことができます｡

appBarのボタンになるアクションを渡したり､ タブを追加したい場合は下のタブを渡したりすることができます｡

背景色を変更することもできますが､ 今はタイトルだけを設定したいと思います｡ titleは名前付きの引数で､

このページのタイトルを設定することができ､ ここでは最初のアプリをタイトルとして追加することができました｡

しかし､ titleはテキストを取らないが､ 見てみると､ titleは実際にウィジェットを取り､

その上にカーソルを置くと､ そこに何が入るかを見ることができる｡

テキストではなく､ テキストウィジェットを受け取ります｡

混乱するかもしれませんが､ テキストウィジェットはプレーンテキストではなく､

プレーンテキストを受け取るウィジェットです｡

この引用符のあるここが､

プレーンテキストです｡

このウィジェットはプレーンテキストを appBar

ウィジェットの title 引数用のウィジェットとして受け取ります｡

ここでは､ 全体的なアプリ・ウィジェットがあり､ 次に scaffold ウィジェットで基本的なページのスタイリングを行い､

appBar ウィジェットで appBar を構成し､ さらに text ウィジェットを受け取ります｡

もちろん､ appBarだけでなくbodyも必要かもしれないので､ ここにbodyを追加します｡

appBarの外側とテキスト・ウィジェットの引数の外側で､

足場の引数の上に追加してください｡

ここでひとつお勧めしたいのは､ 閉じ括弧の後には必ずカンマをつけることです｡

そうすることで､ 非常に読みやすい方法で自動整形することができます｡

キーバインディングでドキュメントをフォーマットすることができます｡ キーボードショートカットに行き､

Visual Studio Codeでドキュメントのフォーマットを検索すると､ キーバインディングが見つかるはずです｡

デフォルトに満足していない場合は､ 変更することもできます｡

このように短いスニペットであれば問題ありませんが､

ウィジェットツリーが長くなればなるほど､ 最後のカンマが自動フォーマットを改善し､ より読みやすくなります｡

これで､ 自分では作らずFlutterが提供する雛形ウィジェットが完成し､

appBarとbodyを渡しました｡

そして､ これを保存すると､ 自動的にアプリケーションが再構築され､ ホットリロードされるはずです｡ ホットリロードとは､ アプリを再起動する必要がないことを意味します｡

つまり､ 現在の状態を維持し､ もしデータを変更しても､ 再起動して上書きすることはなく､ アプリをそのまま維持し､

新しいコードを注入するだけです｡ これは開発中にFlutterが管理するマジックで､

したがって､ 元に戻ってみると､ こちらの方がずっとよく見えます｡

赤と黒のデフォルト､

黒い背景の醜いhelloの代わりに､ appBar､ 小さなドロップシャドウ､

青い背景､ 自動的に背景と対照的な色を持つタイトル､ そして､ これは私のデフォルトテキストで､

このページのメインエリアに出力されています｡

そしてこれが､

Flutterアプリを構築する方法､ ウィジェットツリーで作業する方法､ そしてコードでアプリを構成する方法です｡ 最初のセクションで､ FlutterとDartを使って､

ユーザーインターフェースをコードで構築してモバイルアプリを作る､ と述べたのはこのことを意味しています｡

ここではドラッグ＆ドロップのエディターを使っているわけではなく､

画面に表示する内容を定義するコードを書いているのです｡

そして､ これらの基本的な設定ができたので､

次のステップとして､ 最初の､ もう少し現実的なコースアプリケーションに挑戦してみましょう｡
########
この最初の､ もう少し現実的なアプリケーションでは､ いくつかの質問に答えると､ その選択肢に基づいて､

あなたの性格を診断する､ 非常にシンプルな性格診断クイズアプリケーションを作りたいと思います｡

そのために､ 現在のアプリケーションを使用します｡ この非常に無駄のないアプリケーションでは､

今はデフォルトのテキストを出力するだけですが､ それを基に質問を表示し､ ユーザーが答えを選択できるようにボタンをいくつか設置します｡

そのためには､ 質問を出力するテキストウィジェットが必要です｡ その下には､ ユーザーが別の答えを選択できるようにするためのボタンをいくつか設置したいと思います｡

bodyは白い部分に表示されるウィジェットを追加する場所です｡

bodyにはウィジェットが1つしかないので､ ここに2つ目のウィジェットを追加することはできませんし､ 別のテキスト､ 2つ目のテキストを追加することもできません｡

しかし､

Dartはこれを位置引数を取らないscaffoldに位置引数として渡そうとします｡

これはうまくいきませんし､

ここにプラスを加えて連結することもできません｡

ここでは1つのウィジェットをボディに渡すことしかできないので､

どうすればいいのか？

複数のウィジェットを渡したいのですが､ テキストとボタンがいくつか欲しいのです｡

そのためには､ Flutterにはさまざまなタイプのウィジェットがあることを理解することが重要です｡

可視ウィジェットは､ ユーザーの入力やデータの出力に関連するもので､

ボタンやテキスト､ カードなどのウィジェットがあります｡

もちろん､ これはどんなアプリケーションにとっても重要なことですが､

同様に重要なのは､ レイアウトやウィジェットツリーの動作や見た目を制御するのに役立つ目に見えないウィジェットです｡

また､ Flutterに搭載されているウィジェットは､ 自分たちで作る必要がなく､ 自分たちでは見えないけれど､

コンテンツを構成するのに役立ってくれるものです｡ これらのウィジェットは､ アプリに構造を与え､ ウィジェットが画面にどのように描画されるかを制御するもので､

もちろん超重要です｡

コンテナウィジェットもFlutterに同梱されている非常に重要なウィジェットで､

一度使ってみるとわかりますが､ 両方のカテゴリに属しています｡

デフォルトでは見えないようになっていますが､

見えるようにスタイリングすることもできます｡

####
Maximilian: テキストと､

そのテキストの下にいくつかのボタンを配置するには､

目に見えないレイアウトウィジェットが必要です｡

そして､ そこではColumnウィジェットを使用することができます｡

コラムという名前が示すように､

ウィジェットをコラムにレンダリングするためにあります｡

テキストなどとの違いは､ このコラムには子供という名前の引数があり､ 実際にはウィジェットのリストを受け取ります｡

さて､ 新しいことがいくつかあります｡

このアングルブラケットに挟まれているものが､ 新しいものです｡

そして､ ここの角括弧も新しいものです｡

これはどういうことなのでしょうか？

まずは角括弧から｡

Dartは､ 他の多くのプログラミング言語と同様に､

リストという概念を持っています｡

これまで､ 文字列について､ 整数､

倍数､ オブジェクトについて学びましたが､

結局はすべてがオブジェクトです｡

さて､ リストもデータの一種です｡

リストは基本的にデータの集まりです｡

つまり､ 文字列のリストを持つことができるのです｡

例えば､ ここで変数questionsを追加して､

テキストのリストにすることができます｡

ところで､ ここにあるようなことを書きたいときに､ シングルクォートで文字列を囲んでしまうと､

このシングルクォートが文字列を終了させてしまい､

エラーになってしまうので､ この前にバックスラッシュをつけることでこれをエスケープすることができます｡

ここで起こることは､ このシングルクォートが､

文字列を終了させるクォートとしてではなく､ 文字列の一部であるべきクォート文字として扱われることです｡

だから､ その前にある後ろ向きのスラッシュはそれを実現するものなのです｡

では次に､ あなたの好きな色は何ですか？

あと､ 好きな動物とかね｡

ここでトライアルのコンマもつけてみよう｡

そして､ 今の質問は､ 実際には､ 文字列データのリストでしょう｡

なぜなら､ プログラミングの多くの場面で､

また現実の生活の中でも､ データのリストを扱うことがあるからです｡

携帯電話には､ 実際の携帯電話を例にとると､

連絡先のリストがありますよね｡

お友達､ それは人のリスト､ 人のリストです｡

したがって､ リストはプログラミングにも存在するもので､

基本的にどんなプログラミング言語でも見つけることができますし､

もちろんDartでもそうです｡

リストは角括弧付きで作成されます｡

これも､ 私がここまでやったことです｡

角括弧で作成したため､

リストも下に作成され､ ウィジェットのリストがあり､

それが角括弧ウィジェットのものです｡

これはいわゆる汎用型なので､

ちょっとしたアノテーション（型推論のため､

ここで削除することもできます）を付けることで､

このリストがウィジェットのリストを保持することを Dart に知らせます｡

これは､ 例えば､ 文字列のリストである｡

質問にカーソルを合わせると､

Dartが自動的に推論してくれたことがわかります｡

リスト､ そしてまた､ この角括弧のようなものですが､

ここでは文字列です｡

汎用型は基本的にアノテーションで､

いくつかの型につけることで､ Dartはこれが単なるリストではなく､

例えばここにある特定のデータ型のリストであると理解することができます｡

それは下でも同じことです｡

これはウィジェットの一覧です｡

型推論があるので, ウィジェットを追加し始めたら,

すぐにこれを削除できます．

そしてそこに､ 質問のテキストウィジェットを置き､

すぐに本当のテキストを追加し､

その下にいくつかのボタンを置きたいと思います｡

さて､ Flutterにはさまざまな種類のボタンがあります｡

その一つがRaisedButtonで､

これは背景色とちょっとしたホバー効果を持つボタンです｡

さて､ あなたが使っているFlutterのバージョンによっては､

RaisedButtonがこの例のようにストライクスルーの効果を持つかもしれませんね｡

これは､ Flutterのバージョン2でRaisedButtonが非推奨になったためです｡

さて､ 大きく聞こえますが､ それほど大きな意味はありません｡

RaisedButtonはそのまま使えます｡

不安じゃない､ 使い勝手が悪いわけじゃない｡

このコースにスムーズに参加するためには､

RaisedButtonにこだわることをお勧めします｡

あるいは､ 結局はRaisedButtonの代替品であるElevatedButtonに乗り換えるという手もあります｡

そして､ これから数分間は､ 私がここでRaisedButtonを使っているのと同じように､

ElevatedButtonを使うことになります｡

じゃあ､ コンストラクタに同じ引数を追加するんですね｡

とはいえ､ 前述のように､

当面はRaisedButtonにこだわって､

スムーズに進めていくことをお勧めします｡

今後のFlutterのアップグレードで新しいボタンに移行する予定ですが､

これらの非推奨のボタンを使っているプロジェクトはたくさんありますし､ これらの非推奨のボタンはかなり長い間残っているので､

今のところはこれらのボタンに従うことをお勧めします｡

しかし､ その古いボタンに代わる新しいボタンについて､

その存在理由や機能など､ より詳しい情報を記載したリンクも添付されています｡

しかし､ ここでは､ とりあえず､ RaisedButtonにこだわってみることにします｡

このストライクスルーの効果をなくしたい場合は､

Visual Studio Codeの設定から行うことができます｡

非推奨を検索すると､ この非推奨を表示する設定を無効にすることができます｡

無効にすると､ このストライクスルー効果がなくなります｡

RaisedButton

はウィジェットで､ このクラスをインスタンス化することで作成されます｡

つまり､ ボタンに表示されるテキストです｡

繰り返しますが､ これはウィジェットであり､ 単なる文字列ではありません｡

ここでの子は､ 代わりにウィジェットであり､

したがって､ ここでは､ 回答1が可能です｡

そして､ その行をコピーして､ もう一度追加すれば､

回答2と回答3が得られます｡

さて､ 各ボタンは､ 子ボタンを持つ他に､

onPressed 引数が必要です｡ onPressed

は､ このボタンが押されたときに実行されるべき関数になります｡

とりあえず､ その配線方法がよくわからないので､

ここにnullを追加しておきましょう｡

NullはDartでは特別な値です｡

基本的に何の意味もありません｡

voidとの違いは､ voidが型であることです｡

つまり､ ここではmainが返すデータの種類は空であり､

何もないと言っているのです｡

そして､ nullは型ではなく具体的な値であり､

1という数字が値であるように､ あるいはここにあるこれが値であるように､

nullは値であり､ 何も語っていないのである｡

しかし､ エラーを回避するために追加する必要があるのです｡

そこで､ すべてのボタンにonPressedを追加し､ すべてのボタンにnullを追加しています｡

そしてまた､ コードの書式設定のショートカットを押して､

これをちょっといい感じに書式設定するのです｡

また､ 最初のボタンのnullの後に､

このように末尾のカンマを追加すると､

少し読みやすい形になります｡

このウィジェットには､ いくつかの子ウィジェットがあり､

テキストウィジェット､ そしてレイズドボタンがあります｡

そしてそれを保存すると､

テキストがここに表示され､ 3つのボタンが見えます｡

そこで､ 有効な入力がない限り､

ボタンを無効にしたいと思います｡

しかし､ ここでは､ もちろん､ それらを可能にしたいのです｡

そのためには､ このボタンと何かをする関数をどのように結びつけ､

ボタンがタップされたときに何かが起こるようにするのかを理解しなければなりません｡

もちろん､ スタイリングや画面上のレイアウトを改善することも可能ですが､

これは次のステップで行います｡

とりあえず､ ウィジェットを上から下へ並べるためのカラムの助けを借りて､

複数のウィジェットを隣り合わせにする方法を理解することが重要でした｡

もし､ 左から右へ隣り合うように配置したい場合は､

代わりにRowを使用することになります｡

#####
そこで､ スタイリングを改善することはもちろんですが､ まずはボタンの動作を改善したいと思います｡

今は､ 押しても何もしないのですが､

それは何も配線していないためです｡

ここでonPressedは関数を受け取ります｡ ここが重要で､ onPressedの値はvoidを返す関数で､

これがここでの意味です｡

さて､

以前は､ たとえばこのタイトルでは､ タイトルがウィジェットを必要としていることがわかりました｡

onPressedの上にカーソルを置くと､

この奇妙なものが見えますが､ これは単に引数を取らず何も返さない関数を意味します｡

これは基本的に関数の型定義で､ 引数と戻り値です｡

つまり､ onPressedは関数を受け取り､

ここでいくつかの異なるオプションを得ることができます｡

クラスの外に新しい関数を追加すればいいんだよ､

そんなのダメだ｡

ウィジェットに属するものはすべて同じクラスに属し､ ウィジェットが使用するデータなどもすべて同じクラスに属し､

ウィジェットが独立したユニットであるようにする必要があります｡

というのも､

クラスに関数を追加すると､ メソッドと呼ばれるようになりますが､ これは通常の関数です｡

ここでは引数を取らず､ 何も返さない関数が欲しいので､ ここMyAppではvoidを追加し､

answerQuestionのように好きな名前を付けます｡ 通常､ 関数名は何が起きたか､ 何が起こるかを説明するためのものです｡

ここで､ 私たちはanswerQuestion関数を得ました､

それは引数を取らず､ 何も返しません､ そして､

そこで､ 単に選ばれた答えを印刷しましょう｡

さて､ これで関数が定義されましたが､ これをどのようにonPressedに結びつければよいのでしょうか｡

単純に､ answerQuestionをこのように呼び､

括弧を追加すればOKです｡

この式は void 型であるため使用できません｡

意味があるのか？

無効を返すべき､ そう言っただけではありませんか？

ここで問題なのは､ 混乱することもあるでしょうが､ 理解することが超重要なので､

非常にわかりやすく､

ゆっくりとした手順で説明します｡

問題は､ ここで､ answerQuestionを実行していることです､ 大丈夫そうですよね？

onPressedがクリックされたときに実行したい｡ ただし､ Dartがアプリケーションを起動する際には､ ファイルを上から下､

左から右へと解析することを覚えておく必要があります｡ ここでアプリを実行し､ MyAppウィジェットをビルドします｡ ビルドメソッドが呼び出され､

ビルドメソッドの中で､ Dartはメソッド全体を通して何をビルドするかを調べ､ OKならMaterialAppを作り､

そこに足場､ AppBar､ テキストコラムなどがあると判断し､ DartはFlutterの助けを借りてそのすべてを調べ､

画面に持ってくることができましたが､ RaidButtonに遭遇しました｡

RaisedButtonは､

このテキストである子を持つように構成され､ 次にonPressedについて､ この構文でDartに言っていることは､

onPressed､ onPressedの値は､ answerQuestionが返すものであるべきです｡

もう一度､ DartPadを見てみましょう｡

先ほどaddNumbersを追加しましたが､ addNumbersの結果は最初のresultに格納されます｡

括弧をつけることで､

ユーザーがボタンを押したときではなく､ DartがRaisedButtonを設定するためにそのコードを確認したときに､ Dartがこれに遭遇するとすぐに実行されるようにしました｡

そこでanswerQuestionを実行し､

今度はonPressedの値としてRaisedButtonに渡されるべき値が戻ってくることを期待しますが､ onPressedは関数を欲しています｡ 一方answerQuestionは何も返しません｡

これは何も返さない関数で､ 今は返ってきた値をonPressedに渡しているので､ onPressedには何も返しませんがonPressedには関数が必要なのです｡

つまり､

onPressedにこの関数を渡すのではなく､ この関数の戻り値を渡しています｡

もちろん､ これは私たちの望むところではありません｡

ユーザーがボタンを押したときにanswerQuestionを実行したいので､

onPressedにanswerQuestionのポインタを渡したい理由です｡

では､ 実際の例を考えてみましょう｡

テレビを持っていて､ リモコンのボタンを押すとテレビの電源が入る場合､ テレビの電源を入れることを関数で表現すると､

その関数はturnOnという名前で､ リモコンのボタンを押すとその関数が実行されることになります｡

今､ テレビのリモコンを渡したら､ いつでも好きなときにそのボタンを押してテレビをつけることができます｡

リモコンを渡すと同時に､ 私がボタンを押してあげると､ テレビをつけるという選択肢を奪ってしまうので､

それはまずい｡

基本的にはFlutterに渡したいタイミングで関数を実行することになります｡

そうすることで､ FlutterのonPressed関数にポインターを渡すことになります｡

ユーザがボタンを押したときに実行する関数の名前を

onPressed に伝えています｡

ここでは括弧を付けずにanswer

passed questionを使用します｡ コードの引数などに関数の名前を付けたい場合は､ 常に括弧なしで使用する必要があります｡

ここで､ 2番目のRaisedButtonと3番目のRaisedButtonで､ answerQuestionに同じことをすることができますが､

常に括弧なしで､ 実行するのではなく､ 関数を示すだけです｡

この状態で戻ると､

ボタンが有効になり､ 濃い灰色ではなくなっていて､ ボタンを押すことができます｡

もちろん､

ユーザーには見えないので､ 実際のアプリで使うような機能ではありませんが､

アプリを開発する上では､ 超便利な機能です｡

つまり､ ボタンが動作して､ それを押すとこの機能が実行されるわけです｡

####
さて､ このようにボタンを関数にフックする方法は､ 2通り考えられます｡

ここで､ ステートレスウィジェット内の名前付き関数を作成し､

onPressedに接続します｡

さて､ これを解決するもう一つの方法は､ 無名関数を使うことです｡ これは､

名前があるので､ 名前付き関数です｡

さて､ 本当に必要な関数がここ一か所だけにあり､ アプリケーションの他の場所から呼び出すことがない場合､

ここでは関数を使用するボタンが3つあるのですでにそうではありませんが､ 仮にボタンが1つしかないとすると､

名前付き関数を使う代わりに､ いつでもそうすることができます｡

この場合､

何も得られないので､

空の括弧のペアと､ 矢印関数と実行したいコードからなる1行の式構文があります｡

ここで､ いろいろなことをやって､ 最終的に3つの答えを選んで印刷することができます｡

ここでanswer 1, 2, 3をクリックすると､ answer

1のボタンからanswerQuestion関数が実行され､

answer 2が選ばれ､ anonymous関数からanswer 3が選ばれています｡

無名関数は､ コードの他の場所から呼び出す必要がない場合は､

常に良いアイデアです｡ なぜなら､ 他の場所から呼び出すことができないからです｡

この関数もすぐに実行されるわけではなく､

関数の定義の後に括弧をつけてすぐに実行するのではなく､ 関数本体の引数で関数を定義して､

その関数の定義を onPressed に渡しています｡

典型的なアプリケーションでは､

もちろんユーザーと対話しますし､ ユーザーにアプリケーションと対話する機会を与えたいと思うからです｡

それでも今は､ 舞台裏のことをやっているだけです｡

ここで何かを印刷しているのは､ ボタンが本当に押されたことを確認するためのデバッグには良いことですが､

画面上の何かを変更してから､ この全体のレイアウトや見た目に手を加える方が良いでしょう｡

これらのボタンを押したときに､ 画面上で何かが変化することを確認しましょう｡

####
さて､ 手始めに画面上の何かを変更するために､ ここで本当の質問を出力するようにしましょう｡

この質問リストには2つの質問があり､ アプリの最初の質問から始めたいのですが､

一度ボタンを押したら､ とりあえずどのボタンを押したかは関係ないので､

ここで2番目の要素に切り替えたいと思います｡

では､

そのためにまず､ 最初の要素を入れるところから始めましょう｡ 質問をこのテキストウィジェットにハードコードするのではなく､

質問リストの最初の要素を使用したいと思います｡

そのためにはまず､

questionsを参照する必要があります｡ questionsはここに追加することで変数の名前になりますが､ 今のquestionsは文字列のリストで､

最初の文字列だけを取り出して出力したいのです｡ そのために､ Dartはリスト内の異なるアイテムに異なるインデックスでアクセスするための構文を用意しています｡

各項目にはインデックスがあり､ 最初の項目は0から始まります｡ 重要なのは､

1ではなく0であることで､ インデックスによってさまざまな要素にアクセスできます｡

変数名の後にドットを追加する方法と､

questionの最後にオブジェクトであるリストを保持する方法です｡ リストはDartに組み込まれたデフォルトのオブジェクトなので､

Dartが自動的に提供する非常に多くのメソッドを持っており､ 多くの組み込みメソッドがあることがわかるように､

より複雑なオブジェクトです｡

ここでは､ elementAtというメソッドを使い､

インデックスを渡すことができます｡

好きな色は最初の要素なので､ インデックスが0になります｡

ここに1つ渡すと､ あなたの好きな動物は何ですかと印刷されます｡

もちろん､ ここには動物がテキストで入っているはずです｡

ここでインデックス2を渡すと､ 実はここでエラーが発生するんです｡

スクロールしていくと､ 範囲エラーが発生しました｡ 無効な値は範囲0から1ではありません｡

この範囲で2を使ってみましたが､ 結局エラーが発生しました｡

これは一つの方法ですが､ もっと簡単な方法があります｡ elementAtを使う代わりに､

変数名の後に角括弧を付けて､ そこにインデックス番号を入力することができるのです｡

これは全く同じことをやっているのですが､ 少し短いので､

通常使う構文です｡ これは質問リストの最初の要素にアクセスします｡ したがって､ このwhat's

your favorite colorの質問は､ 現在ここに表示されているものです｡

しかし､ ボタンを押したときにアクセスするインデックスを動的に変更することができればいいのですが｡

なぜならbuildが実行されるたびにリセットされて変わってしまうからです｡

Flutterはbuildを何度か実行していますが､ 画面上のインターフェースを再構築する必要があるときはいつもbuildを実行します｡

このクラスの中で､

私は新しい変数を先頭に追加することができ､ それは最初は0である質問インデックスである可能性があります｡

ここで､ varをintに置き換えることもできますが､ 0に初期化しているので､ Dartはこれを推測することができ､

したがって､ varを使用する方が良い方法です｡

このプロパティを追加することで､

クラスワイド変数をプロパティと呼び､ answerQuestionで使用することができます｡

質問インデックスを取得し､ それを1または単に質問インデックスプラス1に設定し､ 質問インデックスに格納されている古い値を使用して､

それに1を追加し､ この計算が行われた後に質問インデックスに格納されます｡

そのため､ 質問インデックスの古い値は､ 古い値に1を加えたもので上書きされ､ 私は今選ばれた答えを削除することができます｡

そこで､ 質問インデックスをここで更新し､ 質問を出力するときに､ 0を使用する代わりに､ ここで質問インデックスを参照することができます｡

質問リストの要素にアクセスするために使用するインデックスは動的に設定され､

最初は0であり､ 質問が回答された後に1に増分されます｡

最初のボタンを押すと､ 質問のインデックスが変わり､ 2番目の質問である好きな動物の質問に変わるのがわかるはずです｡

また､ ここで質問インデックスを印刷して､ それがうまくいくかどうか見てみましょう｡ これを保存すると､

再構築されるはずです｡ 手動でこのフラッシュボタンを押してホットリロードすることもできますし､ 何らかの理由でアプリが動かなくなった場合は､

ホットリスタートを実行してアプリを完全に再起動します｡ 少し時間がかかりますが､ 最新のコードの一部でアプリを本当に再構築することを確認して､

回答1を押すと､ 動作するようです｡

1と2は2回押したから表示されていますが､ 1回しか押していない場合は､

1回しか実行されないことを証明するために､

もう一度作り直してみましょう｡

しかし､

テキストは変更されず､

「あなたの好きな色は何ですか？

では､ 何が問題なのでしょうか？

コードに間違いがあるのか？

でも､

結局のところ､ このウィジェットの内部状態を変更しようとしていることが問題なんです｡

###

私が言ったこの状態というのは何ですか？ 一般に､ 状態とは､ アプリやアプリ内のウィジェットが使用するデータや情報のことです｡

状態はユーザー名や私たちの場合､

表示したい質問のインデックスなどです｡

アプリ全体の状態とは､ ユーザーが認証されたか､ またはユーザーが新しい仕事を見つけるために使用するアプリを構築している場合､

サーバーから読み込んだ全体の仕事を持つことができます｡ ウィジェットの状態は､ 現在のユーザー入力､ データの読み込み中､

スピナーを表示するか､ またはこのアプリケーションのように､

アプリウィジェットのウィジェットの状態は､ 現在どの質問が選択されているか､ そしてその状態は､ アプリケーション内で変更することができ､

通常は変更されます｡

しかし､ ステートレスウィジェットを拡張しているため､

その名前が示すように､ このウィジェットはステートを持つことができません｡

さて､ これは非常に制限的で奇妙に聞こえるかもしれません｡ なぜなら､ 通常､ 物事が変わるべきインタラクティブなアプリケーションでは､

なぜ､ 変更できないウィジェットがあるのでしょうか？ 一般的にFlutterアプリケーションでは､ 複数のウィジェットを持つことになり､

ここでもすぐに複数のウィジェットが登場します｡ いくつかのウィジェットは､ Flutterに組み込まれているテキストウィジェットのように､

何かを出力するためだけに存在します｡ ウィジェットが作成されるときにテキストが渡されるので､

ウィジェットが存在する間はテキストは変化せず､

テキストを出力するだけで､ テキストがクリックされたりしても反応しません｡

したがって､ テキストは完璧なステートレスウィジェットになりますし､ 実際そうです｡ 多くのウィジェットは､ 特定のスタイル､

特定の色､ または特定の構造でデータを出力することにのみ関係しています｡ しかし､ ウィジェットの中にはデータを変更する必要があるものもあります｡

このアプリのように､ 質問インデックスを変更したい場合､ ステートレスウィジェットをいわゆるステートフルウィジェットに変換することが可能です｡

ステートレスウィジェットとステートフルウィジェットの違いは､ ステートレスウィジェットでは､ ウィジェットとUIをレンダリングするために使用されるビルドメソッドがあることです｡

ウィジェットクラスのコンストラクタを通じて､ 外部からステートレスウィジェットにデータを渡すことができます｡

このデータは変更可能で､

実際にFlutterは外部データが変更されるとウィジェットを再構築しますが､

ウィジェットクラスの内部ではデータは変更されず､ 外部から新しいデータを受け取ることができるだけで､

基本的にウィジェットは再構築されます｡

ステートフルウィジェットにも､ ウィジェットを構築してUIをレンダリングするビルドメソッドがありますが､

ここでは入力データも取得できます｡ つまり､ ウィジェットクラスのコンストラクタから渡されるデータですが､ 内部状態を持つこともできます｡

これが核心で､ 外部､ 入力データ､ 内部状態が変更されると､ ウィジェットは再描画されて､ ユーザーインターフェースが

Flutter によって更新されます｡ これが核心の違いです｡

ここでは､

入力データを受け取らない MyApp ウィジェットがあるだけで､ 内部データや内部ステートを持つことはできません｡

さて､ これをステートフルウィジェットにするにはどうしたらいいでしょうか？ これをステートフルウィジェットにするには､ 単純にステートフルウィジェットにリネームすればいいと思うかもしれませんが､

そう単純ではないので､ 今エラーが発生しています｡

また､ Flutterの拡張機能がインストールされていれば､ Visual Studio CodeやAndroid

Studioでリファクタリングすることも可能です｡ ステートレス・ウィジェットにカーソルを置いて､

それをクリックし､ キーバインディングを使用すると､

ステートフルなウィジェットに変換するよう提案されます｡

しかし､ ここでは､ ステートフルウィジェットを構成するものを順を追って説明したいと思いますので､

そのようなことはしません｡

ステートフルウィジェットはウィジェットで､ ここのマテリアルパッケージで提供されているクラスです｡

しかし, ステートフルウィジェットはステートレスウィジェットより少し複雑です．

実は1つのクラスではなく､

2つのクラスを組み合わせているんです｡

最初のクラスの波括弧を閉じて､ 2番目のクラスを追加し､

その下にあるすべてのコンテンツとビルドメソッドなどを2番目のクラスの一部として追加します｡

これは通常MyAppStateという名前で､

自分のアプリの状態ではなく､ ウィジェットの名前に状態を加えたものです｡ MyAppStateはstateを拡張するようになり､ これで再び中括弧を開くことができるようになりました｡

Stateは再びmaterialからインポートされたクラスです｡ dart､ stateは汎用クラスです｡

さて､ ここからはより複雑な話になりますが､

まず､ なぜ2つのクラスがあるのでしょうか？

なぜなら､

Flutterの内部的な仕組みは､ 後でもう少し深く掘り下げますが､ ウィジェット自体を作り直すことができ､

このクラスも作り直すことができ､ 外部データが変更されると､ 基本的にこれが作り直されることになるからです｡

しかし､

状態は永続的で､ ウィジェットに添付され､

ユーザインタフェースの要素に添付されます｡

このように分離することで､ このデータ､ 状態を永続化しながら､

ウィジェット自体を再構築することができるのです｡ このステートクラスがこのウィジェットクラスに属していることを Flutter

に伝える必要があります｡

しかし､ 私たち人間や開発者にとっては､ MyAppState と MyApp というネーミングで明らかですが､

このネーミングは単なる慣習であって規則ではないので､

Flutter はこのクラスがこのウィジェットに属しているという指標としてこの名前を受け取りません｡

その代わりに､ 接続を設定するために､ 2つのものが必要です｡

まず､ stateは一般的な型なので､ そこに角括弧を追加し､ その間にクラスのポインタを追加します｡

これはDartとFlutterに､ この状態がMyAppクラスに属していることを伝えるもので､

つまりこれは接続の1つの部分となります｡

2番目の部分は､ MyAppクラスの内部､ つまりウィジェットの内部で行う必要があります｡

そこで､

新しいメソッドであるcreateStateメソッドを追加する必要があります｡

ここで､ IDEから提案を受けて､ エンターキーを押すと､ 自動的に追加されるんです｡

createState は引数を取らないメソッドですが､ 最終的にはステートフルウィジェットに接続されたステートオブジェクトを返さなければなりません｡

これは state を継承した

state 型のオブジェクトで､ ステートフルウィジェットである MyApp

に接続されています｡

そこで､ ここでは､ 新しいMyAppStateオブジェクトを返したい｡

ここで､

そのクラスに基づいて新しいオブジェクトを作成し､ そのオブジェクトもこのクラスについて知っているので､ 2つの部分､ 2つのクラスを両端から接続したことになります｡

ここでまたオーバーライドしています｡ なぜなら createState はステートフルウィジェットが提供するメソッドなので､

オーバーライドする必要があり､ また意図的にやっていることを明確にするために､

ここに @Override を追加しています｡ この変更により､ ビルドメソッドはウィジェットの内部ではなく､

ステートの内部に置かれるようになりました｡

この状態で保存し､ アプリケーションを再起動します｡ このような変換を行う場合､ ホットリロードは通常動作しないため､

この緑色の矢印または選択したショートカットで完全な再起動を行う必要があります｡

それでは､ 戻って「回答1」をクリックし､ 「好きな色は何ですか」のテキストを見ると､ やはり何も変わりません｡

私たちは､ まだ答えの質問の一部であるprintステートメントで出力がそこに上がるのを見ますが､ まだUIでは何も変わりません｡

その理由は､ ステートフルウィジェットとステートに変換しても､ Flutterはボタンをタップしたからといって自動的にユーザーインターフェースを更新して再レンダリングするわけではないからです｡

もしどこかをタップして､

Flutterがそれを指標としてすべてを再描画するとしたら､ 私たちのアプリは確実にひどいパフォーマンスになってしまうでしょう｡

その代わり､ Flutter に状態を変更しようとしていること､ そしてこの状態が変更されたときにこのウィジェットを再レンダリングすることを伝えなければなりません｡

私たちは､

状態内のデータを変更するコードをラップすることによって､ それをユーザーインターフェイスに反映させ､ 質問インデックスは､ どの質問が表示されるかを制御するので､

もちろん反映されます｡

そこで､ これを変更するときは､ セットステート関数でラップする｡ set stateは､ 私たちが継承するstateクラスが提供する関数､

正確にはメソッドです｡ set stateは､ 関数､ 通常は匿名関数､ つまり引数のない関数と関数本体を受け取り､ set

state関数に渡したこの関数､ つまり引数に関数を取る関数､ そういうものです､ この関数内で､ コードを動かしたり､

この場合はプロパティ､ ビルドで使うプロパティも変更したりします｡

これで保存して再起動すると､

「好きな色」を見ているときに「答えの1」をクリックすると､

「好きな動物」に変わるのがわかります｡

このコースでは､

ステートレスおよびステートフル両方のウィジェットを使用します｡ 学習したように､ ウィジェットの大部分は実際にはステートレスです｡

なぜなら､ 多くの場合､ 何かをうまく出力することだけに関心がありますが､ 時にはデータを変更したり､

ユーザーの入力に反応して何かを変更したりする必要があるからです｡

ちなみに､

これを2回以上押すと､ 質問インデックスが2になり､ 3つ目の質問にアクセスしようとするので､

もちろんエラーが出ますが､ もちろんそんなことはないです｡

###
さて､ ステートフルウィジェットが追加されましたが､ 最初に簡単に見ておくことが重要です｡ 詳しくは後述しますが､ ここではset stateが実行されたときにFlutterが実際に何をするのか､

簡単にご紹介します｡ Set stateはFlutterにユーザーインターフェースを再描画させる関数ですが､

アプリ全体のユーザーインターフェースではなく､

set stateが最終的に行うことは､ set stateを呼び出したこのウィジェットのbuildを再度呼び出すことです｡

この例では､ MyApp というアプリ全体､

このウィジェット､ このビルドメソッドが基本的にアプリ全体ですが､

このコースの後半では､ より多くのウィジェットを持つ大規模なアプリケーションを作成します｡

さて､ ビルドメソッドは先に進み､ このウィジェットツリーを再構築します｡

基本的に､ これらの指示をすべてもう一度行います｡

なぜなら､ このユーザーインターフェースの大部分は変わっておらず､

すべてのボタンはそのままで､ appBarも同じ､ このテキストだけが変わったからです｡

内部的には､

ビルドメソッドを再度実行しても､ UI全体を再度レンダリングすることはないため､ すべてのピクセルを再描画することはない､ という仕組みが多くなっています｡

最終的には､ 画面上の何が変わったのか､ 何を再描画する必要があるのかを見つけ出すためのツールやメカニズムを持っているだけです｡

そのため､ 「ここのテキストが変わった」「このウィジェットに渡したテキストが変わったからこのウィジェットが変わった」ということがわかり､

最終的にこのテキストだけを更新することになるのです｡

ここでもう一度､

この仕組みや､ Flutterが何を変更したかを知る方法などについて深く掘り下げますが､

これはFlutterにもう少し習熟してからコースを通して掘り下げていきます｡

###
そこで､ Flutterで作成できるもう一つのタイプのウィジェットであるステートフルウィジェットについて､ ステートレスウィジェットとは異なり､

内部データを管理することができることを学びました｡

ステートレスウィジェットでもできますし､ Dartクラスでもできます｡

しかし､ ステートフルウィジェットでは､ 内部データをステートオブジェクトで管理し､

ステートフルウィジェットに接続すれば､ Flutterがそれを拾ってUIもアップデートします｡

これはよくあるパターンで､

よくあるやり方なので､ 他の公式の例でも見ることができますし､

このコースの残りの期間中もずっと使っていきます｡

Dartでは､

質問のインデックスのようなクラスで変数を持つことができ､ その変数をプロパティと呼び､ 関数とクラスを持つことができ､

それらはメソッドと呼ばれます｡

今に始まったことではありません｡

Dartでは､ コードを1つ以上のファイルに入れることもできます｡ ここまでで使ったのは1つのファイルだけですが､

実はすでにその材料から何かをインポートしています｡ dart ファイルで､ Flutter

パッケージによって公開されています｡

Dartのデフォルトでは､ すべてのファイルは､ それ自体で囲まれたエコシステム､

いわゆるライブラリであると言えます｡

これらのファイルは､ importステートメントの助けを借りて､ まだ一緒に動作することができますが､

あなたは､ インポートすることができ､ 別のファイルでアクセスできるものを制御することができ､

例えば､ この状態オブジェクトが別のファイルの内部から使用し､ 変更できることを制限することができます｡

今はこのファイルだけですが､

すぐにファイルを追加して､ 他のファイルでもウィジェットを使えるようにしたいです｡

たとえば､ MaterialApp や scaffold ウィジェット（material

から取得）も使用します｡ なぜなら､ このクラスを使用するのは

MyApp クラスだけであり､ このクラスは状態を作成するために

MyAppState クラスを必要とするからです｡

もちろん､ 私たち開発者は自分のコードを書いているので､ そのクラスを他のどこにも使わないようにすれば大丈夫ですが､ もし大きなチームで仕事をしていたり､

他の開発者とアプリケーションを共有している場合は､ このファイルの外から MyAppState を使用したり操作したりできないように､

何らかの保護手段を講じることができます｡ もし外部から操作された場合､ 他のファイルの中から質問インデックスを変更することができ､

それがウィジェットに正しく拾われないためアプリが同期しなくなったり変なバグが発生するかもしれません｡

さて､

このMyAappStateクラスはmainの内部からのみ使用できるようにDartに通知します｡ そのため､ 定義されているファイルの内部で､

名前の前にアンダースコアを追加します｡ もちろん､ その名前を使用するすべての場所でアンダースコアを追加する必要があります｡

これは見た目だけのことですが､ 実はこの先頭のアンダースコアはDartの特別な構文で､ 通常パブリッククラスであるこのクラスを､

mainをインポートしているどのファイルでも使用できるようにします｡

を作成すると､

パブリッククラスからプライベートクラスになり､ MyAppStateはmainの内部でのみ使用できるクラスになります｡ dart ファイルを使用するため､

この例ではこの MyApp クラスにのみ存在します｡ というのも､ ステートはこのクラスと一緒に動作するので､

本当はMyAppクラスがある同じファイルの中だけで使用できるはずだからです｡

これはよく見られる構文で､ 同じページにある､

この変数とこのメソッドも､ そのファイルの中からしかアクセスできないようにする必要があります｡

質問インデックスの前にアンダースコアを追加し､ さらに質問インデックスを参照するすべての場所で､

これがこのクラスのプライベートプロパティであることを示すことができます｡

その前にアンダースコアを付けて､

さらにここにもアンダースコアを付けてみましょう｡ 繰り返しますが､ これは基本的に私が従っている慣習です｡

しかし､ これは単なる外観上の変更ではなく､ 本当にインパクトがあり､

Dartが理解する構文です｡

しかし､ MyAppStateとその中のすべてのプロパティとメソッドを､

このファイル以外の場所から使用できないようにすることは､

本当に重要です｡

###
数回前の講演で､ 入力データのおかしさについて触れました｡

さて､ 入力データとはどういう意味でしょうか｡

そのために､

新しいウィジェットを作成します｡

さて, このような新しいウィジェットを作るには, 単純に新しいクラスを追加すればよいでしょう．

この作業は､ 以前作業したのと同じファイルで行うことができますが､ 1つのファイルに1つのウィジェットしか持たないというのが､

良い規則です｡

例えば､ 2つのウィジェットが一緒にしか動作せず､ 他のファイルでウィジェットを再利用する予定がない場合などです｡ しかし一般的には､

1つのファイルに1つのウィジェットを置きたいので､ ここではメインの隣に新しいファイルを追加しています｡

dartファイルで､

名前をquestionにします｡ ダーツ､ そしてこれは私の質問ウィジェットを保持する必要があります｡

インストールしたFlutter拡張機能のおかげで､

stと入力すると､ 自動的にウィジェットを作成するためのいくつかの提案が表示されます｡

そうしたら､ ここでFlutterステートレスウィジェットのオプションを選択してエンターキーを押すと､

自動的に新しいステートレスウィジェットが作成されます｡

ここでしなければならないのは､ ウィジェットの名前を追加することだけです｡

これはステートレスウィジェットを拡張したクラスで､ オーバーライドアノテーションでビルドメソッドを取得し､

このモジュールの最初に手動で作成したのとまったく同じウィジェットのセットアップを行います｡

ここではステートレスウィジェットを使っていますが､ これはFlutterパッケージのmaterialファイルから提供されます｡

ウィジェットやビルドコンテキスト､ コンテナのように､ これまで使っていなかったものです｡

ダーツ､

その材料で｡ dartファイルです｡ これは有効なウィジェットで､ コンテナを取り除き､

ここにテキストを追加して､ ここに質問テキストを出力したいと思います｡

ただ問題は､ 私がここの質問をメインで管理していることです｡

ダート

もちろん､ 質問リストや配列を移動させることもできます｡ 配列とリスト､ これらは互換性のある用語で､

質問ウィジェットにリストを移動させることができます｡

しかし､ その場合､ 文字列のリストはそこにありますが､ インデックスを変更するロジックはmainに存在することになります｡

dartファイルです｡

質問ウィジェットに移動させることもできますが､ 後で回答ボタンにも必要になりますし､ 実はすでに回答ボタンはメインにあります｡

dartファイルです｡

質問の中に移動させることができました｡ dart ファイルも同様ですが､ そうすると､ 基本的にすべてを

main から移動したことになります｡ をダーツファイルで質問する｡ ファイルを作成し､ アプリをウィジェットに分割するのは､

そのような発想ではありません｡

このモジュールの以前の講義を思い出してください｡ クラスを作成するとき､

クラス内のデータを初期化するためにデータを受け取るコンストラクタを持つことができます｡

ここでは､ 単に質問テキストまたはそれに名前を付けたいものを持ち､ デフォルト値で初期化しないので､ どのタイプのデータを保持するかを明確にするために文字列に設定します｡

そのためには､

先ほど示した構文で質問コンストラクタを追加します｡ クラス名を繰り返し､ 括弧を追加し､ 中括弧で長い形式にして引数を受け取り､

その引数をこのクラスのプロパティに格納するか､ 短い形式にしてコンストラクタの後にセミコロンを追加し､

この質問テキストを使って､ 質問コンストラクタに渡される最初の引数は質問テキストのプロパティに格納することができます｡

第一引数と言っているのは､

引数リストの中で中括弧で括っていないので､ これは名前付き引数ではなく､ 位置付き引数であり､

中括弧で括った場合のみ名前付き引数になることに注意してください｡

しかし､ ここでは､ 論証は1つでよいので､ 位置の論証をすることにします｡

これは質問テキスト変数またはプロパティに格納される必須の位置引数です｡ そして今､

テキストを期待するテキストウィジェットで､ 私は質問テキストを単に参照することができるので､ このプロパティに､

私はそれを下に参照することができます｡

さて､ それではこのウィジェットをどのように使うのでしょうか？ メインに戻ろう｡ ダーツファイルでは､ テキストウィジェットがここにあり､

今､ 私は以前と同じ方法で選択した質問をテキストウィジェットにではなく､ 質問ウィジェットに転送したいと思います｡

これを行うには､

まず最初に質問ファイルから質問ウィジェットをインポートする必要があるので､ 新しい import 文を先頭に追加し､

ここでの慣習として､ まずパッケージを指す import のブロックを持ち､ 次にあなた自身のファイルを指す import のブロックを持ちます｡

ここで､ 引用符を追加します｡ シングル引用符でもダブル引用符でも構いませんが､ 一度選択したら一貫性を持たせてください｡

そして､ 相対インポートパスを追加します｡ つまり､ ドットスラッシュを追加します｡ これは､ メインと同じフォルダーを探すという意味です｡

dartファイルであり､

次にインポート元のファイル名､ この場合はquestionである｡

ダート

今は質問からインポートしているわけです｡ ダートで､ このファイルにあるものはすべてメインで使えるようになったということです｡

dart ファイルも､ 名前の前にアンダースコアをつけない限り､ 同じです｡

しかし､ questionはアンダースコアを持っていませんし､ メインでquestionウィジェットを使えるようにしたいので､

そうすべきです｡ dartファイルです｡

ここで､ textの代わりにquestionを使うことができます｡ questionのコンストラクタは質問文の値を取得することを想定しているので､ このquestionコンストラクタに値を渡す必要があり､

これはすでにここでメインで正しいのです｡

dartファイルです｡

さて､ 当然ながら､ これには何のメリットがあるのだろうかと思われるかもしれません｡

以前はテキストを使用していましたが､

現在は独自のウィジェットを使用しており､ そこでもテキストを使用しています｡

もちろん､ 単純な再構築には役に立ちませんが､ それでも､

ウィジェットやアプリを小さなカスタムウィジェットに分割することは､ 再構築を効率化し､ コードの管理も容易になるため､

パフォーマンスに役立つ良いアイデアと言えます｡

もちろん､ ここにあるのが単一のテキストウィジェットだけならそれほどでもありませんが､ ここにあるウィジェットの構造が複雑であればあるほど､

メインをスリムにすることができるのです｡ dart ファイルを別のウィジェットに移動すると､

すぐに取得できます｡

繰り返しになりますが､ 単一のテキストウィジェットではそれほど便利ではありませんが､ コース全体を通して進むにつれて､ その利点をより多く理解できるようになります｡

ここがステートレスウィジェットであることが重要で､

コンストラクタでデータを取得するため､ 入力データを受け取ることができます｡

保存してアプリを見てみると､ 以前と同じように表示され､ 便利なことに､ 回答1を押すと､

以前と同じように動作し､ そのボタンを押すとテキストが変化するようになっています｡

このことは､ このスライドでお話したことが真実であることを意味しています｡

左側のステートレスウィジェットでは､

入力データが変わると再レンダリングされる｡

今､ まさにそれが起こっているのです｡

ここがメイン｡ dartでは､ set stateで質問インデックスを変更すると､

ここでbuildメソッドが呼ばれるので､ FlutterとDartはウィジェットツリーを調べて､

最終的に､ ここの質問について､ テキストを正しく変更していることがわかります｡ 質問､ 質問インデックスが変更されたので､

今質問のリストで第2の質問を選択するのです｡

つまり､ questionへの入力データが変わるので､ Flutterは自動的にここでquestionウィジェットのビルドを呼び出すのです｡

技術的には､ ここですべてのウィジェットに対してビルドを呼び出しますが､

ウィジェットは基本的に私が変更したかどうかをチェックし､ ほとんどのウィジェットは変更しませんでしたが､

質問ウィジェットについては､ 新しいテキストを受け取ったので変更されました｡

内部的に変更されたからではなく､

外部からのデータが変更され､ mainのbuildメソッドが再度実行されたからです｡

それが､ 今回の出来事なんですね｡

すでに警告が表示されているので､ ここで行うべき1つの構文の改善ですが､

これは質問ウィジェットのプロパティで､ このように内部で変更することができます｡

もちろん､ ステートレスなのでユーザーインターフェイスには反映されませんが､

技術的にはクラスの内部でこれを変更することができます｡

このクラスは不変とマークされており､

最終的にステートレスウィジェットの内部で発生します｡

しかし､ インスタンスフィールドがあり､ それは最終的に単なるプロパティで､

finalではない､ つまり､ 変更可能で､ このクラスの内部から文字列を変更できます｡

これは､ この値がコンストラクタで初期化された後は決して変更されないことをDartに伝えるものです｡

つまり､ この変更はカウントされないので､ コンストラクタでデータを受け取ると､

それが質問文に格納されます｡ なぜなら､ 結局､ このオブジェクトがクラスに基づいて作成されるときに､

オブジェクトが作成されるときにコンストラクタが呼び出されるからです｡

この時点では､

コンストラクタで受け取ったデータがそのプロパティに格納されているので問題ありませんが､

その後､ このオブジェクト､ つまりこのウィジェットが動作するようになると､ これを再割り当てしたり､ 質問テキストに新しい値を割り当てることができなくなります｡

ステートレスなウィジェットなので､ これを変更しても何の影響もありませんし､

このことを明確にするコードを書くことになります｡

ですから､ ここにfinalを加えることは､ このコースを通してよく見られることであり､ ここに加えるべきことなのです｡

これで､ 前と同じ動作が､ 独自のウィジェットで可能になりました｡

カスタムウィジェットは､ ウィジェットのロジックが複雑になればなるほど､ ますます重要になるでしょう｡

このテキストに最初のちょっとしたスタイリングを加えることで､ すでに少し複雑にすることができます｡

これまで私たちは何もスタイル付けをしていませんでしたが､

質問文のためにここで少なくとも少しのスタイル付けをすることができます｡


####
では､ 質問文のスタイルを決めてみましょう｡ ここでのtextでは､ 実際に出力すべきテキスト以外のものも渡すことができます｡

それがFlutterに内蔵されているテキストウィジェットの位置引数であり､ 素材である｡ dart ファイルで使用されますが､ これもまた､

たとえば style 引数など､

いくつかの名前付き引数です｡ スタイル引数にカーソルを合わせると､ テキストスタイルオブジェクトが得られますが､ これはウィジェットではなく､

マテリアルが提供する TextStyle クラスに基づいた通常のオブジェクトです｡

ダート

クラスをインスタンス化するときはいつもそうですが､

クラス名を使って括弧を付け､ ここにカンマを追加してください｡

さて､ いつものようにコントロールスペースを押すと､ 設定できる項目のリストが表示されます｡

例えば､ 色を変更したりすることができますが､ ここではフォントサイズを設定して､

これを28とします｡ もし､ そうして､ これを保存したら､ 今度はもっと大きくなって､

もっと良くなると思うんです｡

また､ それがセンター分けされていると嬉しいですね｡

これは､ スタイルではなく､ テキスト・ウィジェットの別の名前付き引数､

テキスト・アラインを使えば､ 簡単にできます｡

ここでは､ テキストアライメントを設定することができ､ これにはテキストアライメントの値が必要です｡

ここで､ text alignをインスタンス化することができましたが､

実は､ これは少し違う動作をします｡ text alignを括弧なしで使用し､

さらにdotを使用します｡

では､ このテキストを中央に揃えるというのはどういうことでしょうか？

いわゆるenumと呼ばれるもので､ あらかじめ定義された値のリストと言えます｡

もちろんコンピュータにとっては非常に意味のある0､

1､ 2ですが､ 開発者や人間にとってはそれほど意味のあるものではありません｡

そこで､ Dartでは異なるデータ型であるenumを使用し､

これらの異なるオプションや数値にラベルを割り当てているだけです｡

ですから､ さまざまなオプションがあり､ 人間が読みやすいラベルを使いたい場合､ 裏側では基本的にオプションを識別するための番号だけが必要であるというのは､

常に良い解決策です｡

その背景にあるソースコードについては､ 後ほどご紹介します｡

さて､ どうしてそんなことがわかるのでしょう？ もちろん､

自分で調べてみることも大切です｡

後でまた説明しますが､ とりあえずここで text align center

を使ってみましょう｡ これを保存すると､ テキストが大きくなるだけでなく､ 中央に配置されていることがわかります｡

あまり効果がないのでは？

その理由は､ デフォルトでは､ テキストウィジェットはテキストが必要とするスペースしか割り当てないからです｡

しかし､ テキストを別のウィジェットで包むことで､ これを変更することができます｡

例えば､ コンテナウィジェットです｡ コンテナはテキストに巻き付けることができます｡ テキストの後に括弧を開いて閉じ､

コンテナはテキストという名前の子を受け取ります｡

コンテナはデフォルトではかなり不可視で､

画面に表示されるようなものは何もありません｡ それを保存しても､ 右には変化せず､

以前と同じです｡ コンテナでできることは､ 幅を設定し､ これを2倍にすることです｡

無限大､ ． infinity

は基本的に､ コンテナが取得できる最大限のサイズ､

最大限の幅を確保するための幅を与えます｡

なぜなら､ コンテナが画面の幅いっぱいになり､ テキストも自動的にコンテナの幅いっぱいに表示されるようになったからです｡

これはFlutterのデフォルトの動作で､ Flutterを使ってアプリを作るうちに､

このような動作に慣れ､ 感覚をつかむことができるでしょう｡

だから､ 今は新しい情報がたくさんあっても心配ありません｡ それはFlutterを使えば使うほど､

なじんでくるものです｡

つまり､ テキストはコンテナの幅いっぱいに表示され､ コンテナはデバイスの幅いっぱいに表示されるため､

中央揃えの効果が得られます｡

さて､ この最初の小さなスタイリングの旅を､ containerに別の名前の付いた引数を追加することで締めくくりましょう｡

マージンとは､

コンテナの周囲にスペースを設けることです｡ コンテナ・ウィジェットは特殊なウィジェットで､ スペースを設けたり整列させたりするための多くの設定を持っていることを理解する必要があります｡

コンテナの中核は常に子であり､ この例ではテキスト・ウィジェットがそれにあたります｡

しかし､

その周囲にパディングを設定することができます｡ パディングとは､ コンテナの内部で間隔を空けることです｡

ボーダーの外側にはマージンがあり､

コンテナの周囲やコンテナと隣接する要素との間の間隔を表します｡

真ん中の子､ パディングがあればその周り､ ボーダーがあればその周り､ マージンがあればその全てにマージンがあるということを念頭に置いておくことが重要です｡

このコンテナでは､

ボーダーやパディングを設定していませんが､ マージンを設定しています｡ マージンはEgeInsetsGeometryタイプで､

実際にはEdgeInsetsを呼び出して､ これらのオプションのいずれかを指定して作成されます｡

クラスは複数のデフォルトコンストラクタを持つことができ､

オブジェクトのメソッドとしてそれらを呼び出すことができます｡

次の講義でもう少し深く掘り下げますが､ 今は当たり前のこととして考えてください｡

は､ コンテナの周囲の全方向に一定の値をマージンとして割り当てることができます｡ onlyを使えば､

例えば上だけとか下だけとか､ ある特定の方向をターゲットにすることができる｡ ここでは､ all を使用します｡ all

には､ 単純に

2 倍の値を渡します｡ ここでは､ 10 を追加して､

コンテナの周囲に 10 デバイスピクセル分のマージンを取ります｡

コンテナ､

マージン､ 新しいタイプのコンストラクタ､ text align center のような静的フィールドなど､ 明らかに多くの新しいものがありましたが､ これらはすべて､ このロジック､ この少し複雑なウィジェットを独自のウィジェットで使用し､

メインで使用するときにその複雑さを隠していることを表しています｡

これは､

アプリをカスタムウィジェットに分割したい理由を示す素晴らしい証拠です｡

その代わりに､

特定のタスクにフォーカスできるさまざまなカスタムウィジェットを用意しています｡ たとえば､

このタスクは質問をきれいにスタイリングして出力することです｡

さて､ これで次回の講義では特殊なコンストラクタに飛び込んでみましょう｡

###
では､ TextAlignはどうなっているのでしょう｡ centerとEdgeInsetsがあります｡ 全て？ これらはDartの特定の機能であり､

Flutter固有ではなく､ 全く同じものではありません｡

これは特殊なコンストラクタで､ EdgeInsets には複数のコンストラクタがあります｡ クラスタイプの後にドットを追加すると､

これらのコンストラクタがすべてここに表示されます（括弧なし）｡

現在､ これらの機能は､ オブジェクトをさまざまなバリエーションで作成できるようにするために存在しています｡

MacOSではcommand､ Windowsではcontrolを押しながら､ もっと知りたいことにカーソルを合わせるとリンクに変わり､

それをクリックするとフレームワークのコードに移動します｡

先ほど説明したenumは､

enumキーワードを使って手動で作成するものです｡

もっと参考になるのは､ ここでEdgeInsetsに飛び込んでみることです｡

EdgeInsetsがこれを継承しているのは良いことです｡

つまり､ EdgeInsetsをインスタンス化すると､

自動的にEdgeInsetsGeometry型のオブジェクトを取得することになります｡

ここでは､ いくつかの特別なコンストラクタがあることがわかります｡

クラス名を繰り返していますが､ これは常にインストラクターであることを意味し､

その後に直接括弧を追加するのではなく､ いくつかの名前をドットで追加します｡

ここであまり内部的なことに立ち入らずに､ 結局のところ､ 各コンストラクタはこのクラスの新しいインスタンスを作成しますが､

異なる構成､ 異なる設定で､ 異なるEdgeInsetsを簡単に作成できるようにするために行われることを意味するだけです｡

これらのユーティリティ関数やユーティリティコンストラクタを使用して､

さまざまな構成のEdgeInsetsコンテナを設定することができます｡ DartPadに戻ると､ personにも同様のものを作成することができました｡

nameとdotを追加して､ veryOldなど好きな名前をつけて､

その中で名前を受け入れ､ このコンストラクタはデフォルトで年齢を60に設定するとすることができました｡

つまり､ ここではコンストラクタで年齢を設定することはできず､ 常に60に設定され､ 名前だけを設定することができるのです｡

このコンストラクタは､ 名前だけを設定したい60歳の人､ p3を作成したい場合に便利です｡

そこで､ veryOldコンストラクタを使用して､ これを再びMaxに設定することができます｡

という名前を付けて､ p3もプリントしています｡ を実行すると､

Max と 60 が表示され､ これが p3 オブジェクトの出力になります｡

特殊なコンストラクタは､ 通常のコンストラクタと同じ種類のオブジェクトを生成するために存在しますが､

あらかじめ定義された設定や､ コンストラクタの内部で実行されるさまざまな動作があります｡

###
回答ボタンに関数を渡すとうまくいきます｡

次のステップとして､

常に 1 と答えるのではなく､ 意味のあるテキストを表示するようにしたいのですが､

ちょっとした様式美として､ テキストの色を調整したいと思います｡

このカラーコードをテキスト色に割り当てると､

当然ながらこのテキストは白になります｡

なぜなら､ 質問は単なる文字列､

質問そのものではなく､ 利用可能な回答に関する情報を含んでいなければならないからです｡

もちろん､ 質問が単なる文字列である限り､ 質問テキスト以外の追加情報をそこに入れることはできません｡

そこで今必要なのは､ 複数の情報をグループ化できる､ より複雑なオブジェクトです｡

質問のテキストだけでなく､ 回答のテキストもグループ化することができます｡

必要な機能をすべて備えた新しいクラスを作成し､ そのクラスを使ってオブジェクトを作成すれば､

完全に責任をもって管理できますし､ まったく問題ありません｡

しかし､ このコースではDartについて少し学ぶこともできますので､

Dartに組み込まれている別のデータ構造を紹介します｡ これは､ 比較的些細なデータ構造で､

テキストよりも複雑なものがある場合に便利です｡

マップの作成は中括弧を使うか､ このようにマップクラスを使って行いますが､ ここでは中括弧の構文を使ってみましょう｡

つまり､ 角括弧で作成するリストと少し似ていますが､ 今のマップは値のリストではなく､

キーと値のペアのコレクションになっているのです｡

値を特定するためのキーがあり､

例えばここでは質問文のキーがあります｡ キーを引用符で囲みますが､ 二重引用符でも単一引用符でもかまいません｡

キーは必ずしも文字列である必要はなく､

1などの数字をキーにすることもできますが､ 多くの場合､

文字列を使用します｡

今､ 質問リストの中の1つの質問は文字列ではなくマップになり､

そのマップは質問テキストを持っていますが､ 今は質問テキストだけでなく､

答えのリストも持っているべきです｡

もちろん､

これらのキーの名前は完全にあなた次第です｡

また､ 回答は文字列ではなく､ リストになります｡ このリストには､

回答テキストのリストを表示することができます｡

ここでは､ 好きな色を尋ねているので､ 例えば黒にすることもできますし､

赤､ 緑､ 白もあります｡

もちろん､ クイズに複数の質問をしたいので､

これを複製して､ 2つ目の質問を2つ目のマップの質問テキストとしてここに追加します｡ 最後に二重引用符を削除して､ 次に冒頭と､

ここで私の回答テキストは､ 動物を尋ねているので､ ここではウサギ､ 蛇､ 象､

ライオンとしましょう｡

もちろん､

ここに好きなものを入力してください｡

他の全ての値と同じように､

もちろんオブジェクトをベースにしていますが､ Dartに組み込まれているマップクラスをベースにしています｡

これはリストに対して角括弧を使うのと同じで､

より複雑なデータをキー・バリュー・ペアとして管理したい場合に最適な省略記法です｡

#
質問がマップとして再追加されたので､ ここで質問テキストを渡すために､ インデックスによって質問を選択するだけでは十分ではありません｡

もちろん値に興味があるわけですが､

この値にはキーでアクセスします｡

では､ 特定のキーの値を取得したいことをDartに伝えるにはどうすればよいのでしょうか｡ この下で､ 質問リストの中の特定の質問を選択していますが､

これは重要なことで､ このリストはまだリストです｡

このマップには､

文字列のキーとさまざまなオブジェクトの組み合わせがあり､

Dartは､ ここにオブジェクトの値を持つマップがあると推測しています｡

つまり､ マップのリストがあり､ 各マップは文字列のキーとさまざまな種類の値を持っています｡

今､ その価値にアクセスするにはどうすればいいのか？

ここでは､ インデックスを通して特定の質問にアクセスしているので､ インデックス0では最初のマップが､

インデックス1では2番目のマップが生成されます｡

特定のキーにアクセスしたい場合は､ ここでも角括弧を使います｡

中括弧ではなく角括弧です｡ 角括弧を使ってマップ内のキーにアクセスし､

角括弧の中でキー名を使うだけです｡

すべての質問において､ インデックス0､ 1､ 2などの質問にアクセスし､ 選択された質問マップにおいて､

キーであるquestionTextの値にアクセスしています｡

つまり､ この値､ この値､ この値にアクセスすると､

この文字列になり､ それが質問に転送されるということです｡ 私たちの価値を質問に転送することができ､

それはもちろんかなりきれいです｡

さて､ 選択した質問に基づいて動的に回答を作成するにはどうしたらよいでしょうか｡

常に4つの答えを持っているので､ ここで答えをハードコードすることもできますが､

もちろん､ 4つの答えがある質問と3つの答えしかない質問を用意することも可能です｡

そこで､ 現在の質問に基づいて動的に回答ウィジェットを作成できればいいのですが､

それはもちろんDartで実現できます｡ 回答ウィジェットをここにハードコーディングする代わりに､

あなたができることは､ ここにあるあなたの質問にアクセスすることができます｡

つまり､ リストを別のものに変換して､ 地図のリストの代わりにウィジェットのリストを作成し､

そのウィジェットのリストをここに追加して､ その列のウィジェットリストにマージすることができます｡

そのために､ マップ方式があるんですね｡

繰り返しになりますが､ 質問はリストであり､ リストはDartにおけるクラス､ オブジェクトであり､ そのクラスはマップメソッドを定義しています｡

mapメソッドは､ mapを呼び出しているリストのすべての要素､ つまりこの場合は質問リストのすべての要素に対して､ mapの引数として渡さなければならない関数を実行します｡

関数をmapに渡す必要がありますが､

ここで作成した名前付き関数を使うこともできますし､

匿名関数を使うこともできます｡

この関数は質問リストのすべての要素に対して実行され､

現在の関数実行のための現在の要素は､

この関数内の引数として受け取られ､ すべての要素に適用されるからです｡

ここで質問､ 見ている質問を取得し､ ここで新しい値を返す必要があります｡ mapは基本的に古い構造を維持する必要のない新しいリストを返すので､

マップのリストである必要はなく､ ウィジェットのリストであっても構いません｡

さて､ ここでウィジェットを返したいのは､ question の各要素に対して､ 基本的にそれを置き換える新しい要素を返したいからで､

これが今ウィジェットになるはずです｡

ここで､

新しい回答ウィジェットを作成し､ その回答ウィジェットに質問を転送したいと思いますが､ 実は今､

間違ったマップを呼び出しています｡

実は､ 今見ている質問に対する私の答えを全部見てみたいんです｡

ここで､ 現在選択されている質問インデックスの質問にアクセスし､

キーを選択します｡

そのため､ mapはすべての回答に対して実行される関数を受け取り､ ここで私は回答を取得し､

その回答を回答ウィジェットに転送しています｡

ここで､ mapがクラスオブジェクトに定義されていないというエラーが発生しました｡ ここで発生している問題は､

Dartが答えのキーが常にリストを保持しているという推論に失敗していることです｡

ここではそうなっていますが､ Dartにはそれが見えていないだけで､ 単にDartが検出できないだけなのです｡

この部分を括弧で囲み､ asキーワードを追加することで､

Dartに「これは特定の型を持ちます」と伝えることができます｡

今出ているエラーは別のエラーで､ 後で修正するので心配ありません｡

しかし､ これで文字列のリストをマップすることができるようになりました｡ したがって､ ここでの回答は文字列であり､ 回答するためにその文字列を転送するのである｡

もちろん､ 現時点では answer は文字列を受け取らず､

この関数ハンドラのみを受け取るので､ answer

widget の 2 番目の引数として､

出力される回答テキストを受け取ります｡

現在､

回答テキストを受け取っていますが､ ウィジェットを作成するときに､ 回答の中にある回答テキストは､

回答ウィジェットに渡す最初の値ではなく､

2番目の値です｡ 最初の値は､ 選択した回答に対するハンドラで､ そのためには､ もちろん _answerQuestion

関数にポインタを渡したいと思います｡

そこで､ 作成するすべての回答に対して､ これを転送するようにしました｡

これは大変な作業で､ リストをウィジェットのリストにマッピングするという､

混乱しそうな設定であることは承知しています｡

map はリストを生成しませんが､

いわゆるイテラブルと呼ばれる､

さまざまなイテラブルの親クラスのようなものを生成します｡

また､ mapは元の質問リストを変更しないことに注意してください｡

この変数やそこにある値を変更するのではなく､

古いリストに基づいて代わりに新しいリストを生成し､ その関数の本体で行う変換がmapに渡されます｡

残りの問題は､ こことここにリストがあることです｡ カラムもウィジェットのリストを取りますが､

これではネストしたリストになってしまうので､

リストの中にリストを追加します｡ 実は､ この子リストの中にいくつかの個別の項目を入れたいのですが､

そのためには､ Dartで利用できる別の演算子､ いわゆるスプレッド演算子を利用することができます｡

この前に3つの点を追加すると､ 警告が表示されます｡

これは比較的新しい演算子ですが､ 最近のバージョンのDartではサポートされています｡

このスプレッド演算子が行うことは､ 3つの点がここで行っているように､

リストを取り込んで､ リストの中のすべての値を取り出し､ 個々の値として周囲のリストに追加することです｡

このように､ すべての回答をアンサーウィジェットに変換しているのです｡

そして､ これがリストであることを確認してから､ 生成された回答ウィジェットをこのリストに追加します｡

もちろん､ これは大変な作業でしたが､ これを保存すると､ 確かにここに4つの答えの値が表示されます｡

1つを選択して次の質問に進むと､ これらの答えが変化していることがわかります｡

もちろん､ 持っていない質問に行くことを避けるようなチェックを実装することもできますが､

今のところは現状に満足しています｡

######
ここで､ 意図的に出したエラーを取り除くためにアプリを再起動すると､ 最初のアプリがうまく動作していることがわかります｡

もちろん､ どの答えを選んでもいいというわけではなく､

3つ目の答えでアプリが壊れてしまうのです｡

これらはすべて私たちが取り組むことができることであり､ 今後取り組む予定ですが､ それ以外は､ 私たちが知っておくべき中核的な重要機能の多くをカバーしました｡

さて､ ここで再びFlutterから離れ､ Dart特有の機能を見てみたいと思います｡

この機能は､ この色を見てもらったときにすでに見てもらいました｡

このクラスをクリックすると､ インスタンス化せずにアクセスできる静的プロパティをグループ化したクラスであることがわかります｡

しかし､ 私が主に見たいのはそこではなく､

この const

キーワードなのです｡ 回答ウィジェットでは､ finalも用意しています｡

finalもconstも､ 変化しない値を作っているように聞こえますが？

定数値とは､ おそらく変数の逆で､ 変化しない変数であり､

それゆえ格納される値もかなり一定ですが､ 最終値もまた変化しない値です｡

では､ 何が違うのでしょうか？

メインに行かせてください｡ ダーツファイル､

ここ､ この質問リストが最終的には定数になっています｡

なぜ？

なぜなら､ ここの価値観は決して変わらないからです｡

なるほど......でも､

それってファイナルと同じじゃないですか？

実際､ varの代わりにfinalを使うこともできますし､ varを使うよりもその方がいいでしょう｡

なぜなら､ プログラムが実行されたらこれらの値を変更するつもりはない､ という事実が明確になるからです｡

プログラムが実行された時点から値が変化しない場合にfinalを使用します｡ 例えば､ 質問と回答のウィジェットでは､

ここに値を代入したときに初期化されますが､

その後は変更されないので､ ここのプロパティはfinalです｡

ここがメイン｡ dartで質問を作成し､

回答を作成し､ 新しい質問を選択すると､ 最後にFlutterはこの構築メソッドを再実行します｡

これはset stateを呼び出したためで､ このツリーとすべてのウィジェットを再構築し､

新しいオブジェクト､ たとえば質問クラスの新しいインスタンスを作成し､

それに値を渡します｡

この質問ウィジェットは一度作成されると変更されませんが､ 作成されると前回の質問とは異なる値になります｡

なるほど､ 納得です｡

実行時に最終的な値が記録されますが､ コードを書いている時点では､

開発中とコードがコンパイルされた時点では､ 質問ウィジェットは異なる質問テキストで動作することができるので､

値は不明確です｡ このコードが実行される時点で､ 最終的な値を記録しますが､ このコードを書いている時点では､

最終的な値がどうなるかはわかりません｡ また､ 本当に重要なことですが､ 例えば質問ウィジェットでは､

最終値は1つではなく､ 作成する具象インスタンスに依存します｡

この質問リストについては､

変更することはないのですが｡

私たちは､ 質問を出力するときに､ ここで別の質問を選択しますが､ ここで質問リストを変更することはありません｡

私たちは､ 他の場所でそれを表示するためにそれにアクセスし､ 他の場所でそれを表示するために質問テキストにアクセスするだけです｡

したがって､

ここでは､ finalのような実行時定数ではなく､ コンパイル時定数であることを明確にするために､ 実際にconstを使用する必要があります｡

これでコンパイル時定数も暗黙のうちにランタイム定数を意味するようになった｡

もしあなたがコードを書いている時点で､ 最終的な値が何であるかが分かっていて､ この値が決して変わらないことが分かっていれば､

もちろん実行時にも変わることはありませんが､ この質問リストは決して変わらないので､

最終的な値はコードが実行されるときに記録されるのではなく､ あなたがコードを書いた後にすでに記録されているのです｡

そして､

これは重要な概念であり､ なぜfinalとconstの両方を見るのか､ どのように違うのかが明らかになることを期待しています｡

さて､ 変数名の前にconstをつける以外に､ 値の前にもconstをつけることができますが､

その違いは何でしょうか？

違いは､ 変数名の前に付ければ変数は一定､ 値の前に付ければ値は一定ですが､

同じではないでしょうか？

そのためには､ Dartがどのようにオブジェクトを管理するかを理解する必要があります｡ すべてのオブジェクトは､

リストであれウィジェットであれ､ 他のクラスをベースにしたオブジェクトであれ､ Dartによってメモリに保存されます｡

そして､ オブジェクトを保存していると思っている変数に､ Dartが実際に保存するのは､ メモリ上のオブジェクトのポインタです｡

もしあなたが家を持っていて､

郵便局に行って手紙を出そうとしたら､ 手紙に住所も書かなければならない｡ もちろん､ 家ではなく､ 手紙に住所を書く｡

馬鹿な例だと思われるかもしれませんが､ 結局のところ､ ここで起きているのはまさにこのことなのです｡

オブジェクト自体をコード内の必要な場所に持っていくと､ 常にコピーしなければならないため､

多くのメモリを消費してしまいますが､ その代わりに､ Dartは非常に賢く､

オブジェクトをどこかに一度だけ保存し､ その後は異なる場所でアドレスを取得するだけです｡

結局､ この機能で何をするかということでもあるのです｡ 結局､ 関数もこの関数コードのアドレスを保持する変数に過ぎません｡

したがって､ この関数にあるアドレス､ つまりポインタをウィジェットに渡して､

それを onPressed にバインドすることができます｡

さて､ 変数を定数にすると､ 暗黙のうちに値も定数として扱われますが､

その逆も可能です｡

可変の質問をしても､ 一定の値を持つことができ､ さて､ その結果はどうなるのでしょう｡

今､ 許可されているのは､ あなたが質問に新しい値を割り当てることです｡ あなたは質問を新しいリストと等しく設定することができ､

それが空のリストであっても､ これは技術的に新しいリストであり､ それはメモリ内の新しいオブジェクトです｡

これは要素のない古いリストではなく､

新しいリストであり､

新しいオブジェクトです｡ 私はこの新しいオブジェクトをquestionsに格納し､

したがって私が実際にquestionsに格納したのは､

その新しいオブジェクトのアドレスです｡

ところで､

これからの講座では､ オブジェクトを変数に格納する､ リストを変数に格納する､ 技術的にはアドレスを格納するのですが､ 他の言い方の方が簡単なので､

この点は理解しておいてください｡

ここにアドレスがあったのに､

新しいアドレスで上書きしています｡ questionsが変数であれば､ ここでの値が定数であっても許される｡

しかし､ 質問を定数に変更すると､ 今度は定数変数に新しい値を代入しようとしているので､

そこでエラーが発生しますし､ それは許されません｡

そのため､ 決して変更したくない場合は､ ここでconstを使用する必要があります｡ なぜなら､ 誤って新しい値を代入するような間抜けな間違いを避けることができるからです｡

でも､ そのコンストバリューは今どうなっているのでしょう？ そのために､

簡単に他の例を挙げましょう｡ 例えば､ ダミーという変数があり､ それがhelloというテキストのリストだとします｡

リストオブジェクトに用意されているメソッドの1つであるaddを呼び出すと､

新しい値を追加することができます｡ したがって､ ここにダミーを印刷してリロードすると､

hello Maxがここに印刷されます｡

重要なのは､ mapと違って､ addは元のオブジェクトを修正するのではなく､ 元のリストを修正することです｡

そこで､ ここでは､ 元のリストに新しい項目を追加して修正しました｡ もしここにconstを追加したら､ これは動作しません｡

もしここにconstを追加してこれを保存したら､ 今度はコンパイル時にエラーが発生します｡

これはコンパイル時定数だからです｡ そのため､ コンパイル時に「変更不可のリストに追加できない」というエラーが発生し､ それはそれで素晴らしいことなのですが､ 「変更不可のリストに追加できない」というのは､

「変更不可のリストに追加できない」ということです｡

もしあなたが､ 変数を再利用して全く新しい値を代入したいリストがあるとしたら､

それはvarなので許されますが､ そのオブジェクトを決して変更したくない場合は､

値を定数にする必要があります｡

もし､ 値が決して変化しないことがわかっているリストがあれば､ 変数全体を定数にして､

変数とリストの両方を変化から保護することができます｡

また､ 一度初期値を取ったら変わらないことが分かっているデータは､ finalにする｡

もちろん､ コース全体を通してこれらのことを使っていきますので､

finalとconstを使った作業がだんだん自然にできるようになります｡

というのも､ 最初からきれいなコードを書くことを学んでほしいからです｡

Flutterのクラスや他の例､ そしてこのコースでも､ finalとconstをたくさん目にするでしょう｡

###
まだ多くの機能が不足していますが､ 私たちの最初の小さなダミーアプリケーションは､

心配することなく､ ゆっくりと形を成しています｡ しかし､ 現時点では問題があります｡

質問を終えた後にエラーが発生し､

これは一般的に提供したいユーザーエクスペリエンスとは言えません｡

その代わり､ 質問がある間は質問と回答の列を表示しますが､

質問のリストを使い切った時点で､

他の出力､ つまり､ あなたがやりましたというメッセージや最終スコアなどを表示するとよりよいでしょう｡

そのために､ やりたいことが2つあります｡

そこで､ 質問を終えたら､ 別のウィジェットを出力したいと思います｡

ですから､ 質問と答えの列を作る代わりに､ 例えば中央揃えのテキストを表示して､

「とりあえずやってみました｡

というわけで､ bodyに渡す値のifチェックが必要なんですね｡

質問と答えがある限り､ この列を渡すか､ 他のものを見せるか､ いわゆる三項式で､ これは他のプログラミング言語にもある機能ですが､

基本的には1行のifチェックです｡

そういえば､

イフ・チェックは全然勉強してないよね？

では､ まずifの意味から説明しましょう｡ ifキーワードは条件付きでコードを実行したい場合､

コードで使用することができます｡ 例えば､ answerQuestionで､

ここにifキーワードを追加し､ 括弧と中括弧の間に条件を追加して､ この条件が満たされた場合にのみ実行するコードを囲むことができます｡

したがって､

0から始まる質問インデックスが質問の長さより小さいかどうかを確認することができます｡

Dartにはスコープという機能があり､ このメソッドにスコープされ､

クラス全体ではなく､ ビルドメソッドでのみ利用可能な変数または定数として扱われることは既に述べました｡

その解決策は比較的簡単で､

リスト全体をビルドの外に出して､ 変数または定数としてMyAppStateクラス全体に次のように追加するだけです｡

しかし､ ここでは､ staticフィールドのみがconstとして宣言できるというエラーが発生します｡

したがって､ 基本的にDartはクラスレベルでconstを許可していません｡

解決策は2つあります｡ staticキーワードを前に追加してこれを解決するか､

これをfinalに変更して､ ここにconstを追加して､ このリストが決して変更されないことを明確にするか､

どちらもOKです｡ 今､ 質問はこのクラスのプロパティであり､ この関数を含め､ クラスのどこでも使うことができます｡

それを踏まえて､ このイフチェックに戻ります｡ ここで､

私はブール値の比較をしています｡ 質問インデックスと質問の長さを比較しています｡

これが行うことは､ 長さが3であるとすると､

それが質問インデックスよりも大きい場合､ 質問インデックスが質問の長さよりも小さいかどうかをチェックしているので､

ここではtrueを返します｡

そして､ これも今まで触れていなかったDartの重要な型､

booleanです｡ ブーリアンは真､ ブーリアンは偽とする｡

Dartにはboolという特殊な型があり､ trueとfalseという2つの値しか持たないので､

ifチェックに最適です｡ この式は自動的にブール値を生成します｡ この比較演算子のおかげで､

この条件が満たされれば真､ そうでなければ偽を生成し､ この式が真に解決された場合のみ､

このifブロックに入ることができるのです｡

もしtrueなら､

このコードは常に実行されますが､ もちろん､ それは少し意味のないチェックです｡

同じことがfalseにも当てはまり､ このコードは決して実行されません｡

その代わりに､ あるときはtrueを返し､ あるときはfalseを返すような比較やチェックをしたいものです｡

smaller than演算子の他に､ greater than､ small than or equal､ greater than

or equalがあり､

2つの値が等しいか等しくないかでなければならないのです｡

これらは､ ここで使用できる他の演算子ですが､ 私がチェックしたいのは､ 質問のインデックスが質問の長さよりも小さいかどうかです｡

これは､ questionsに3つの項目があるので､ ここでもquestionsは3つのマップを持つリストなので､

questionsの長さは常に3であることを意味します｡

質問インデックスが0から始まる場合､

0は3より小さいので､ この条件は真になります｡ したがって､ 最初のボタンクリックの場合､ これは真になるので､

ifブロックにそれを作成し､ 質問インデックスを1に変更するのです｡

つまり､ 2回目にボタンをクリックすると､

1が3より小さいので､ これも真となり､

次に2に変更したので､ 3回目も真となる｡

そこで､ ここで実際にやってみたいのは､ もっと質問があることを印刷することです｡

しかし､ 先ほど説明したように､ インデックスを変更する前にチェックするため､

質問がなくなっても同様です｡ そのため､ まず質問のインデックスを変更してから､

さらに質問があるかどうかを確認する必要があります｡

しかし､ アプリを再起動すると､ ボタンをクリックしたときに､ 最初の2回のボタンクリックで2回質問があることがわかりますが､

その後3回目のボタンクリックでは､ 出力が表示されないので､ ここでエラーの上にスクロールすると､ 確かに2回質問があることがわかりますが､

3回目のクリックでは､ もはや表示されません｡

これは通常のifチェックですが､ これをウィジェットツリーに持ってくるにはどうしたらよいでしょうか｡

###
そこで前回の講義では､ if文について紹介しました｡ if文は､ ifとifを括弧でくくり､ 条件を記述することで作成します｡

この条件が満たされるたびに､ 中括弧で囲まれたif文の本文に反映されます｡

中括弧で囲まれた本文の後では､ セミコロンを付けません｡

さて､ この括弧の間には何が入るのでしょうか？

今言ったように､ 条件ですが､ 正確に言うと､ その間にあるのは実際には真か偽に解決する式で､

これはDartでは特定の型ですが､

この型は多くのプログラミング言語に存在し､ booleanと呼ばれています｡

例えば､ ユーザーのログイン状態を追跡するための新しい変数があり､

これはtrueまたはfalseに設定でき､ ブール値になります｡

ブール値とは､

真か偽のどちらかの値であり､ それ以外の値はありえない｡ プログラミングではしばしばこの2つの選択肢があり､

特にif文と組み合わせてブーリアンが必要になります｡ なぜなら､

最終的にある条件が真であればこれを行い､ ある条件が偽であればこれを行わずに､

if条件で何か他のことを行うかどうかを判断したいからです｡

このブロックは､ if条件で指定することで､ このブロックが満たされない場合の代替手段を用意することができます｡

しかし､

elseブロックは必要ありません｡ ifブロックだけであれば､ このコードを実行するか､

この条件が満たされない場合は何もしないか､ elseブロックがあれば､ 実行する代替コードを用意すれば､ 全く問題ありません｡

つまり､ どちらも可能であり､ その鍵を握るのがブーリアンなのです｡

つまり､ ブール値を保持する変数を参照し､

コードのどこかでこれを動的に設定する方法をとっているはずです｡

しかし､

もしisLoggedInがコード内の他の場所で制御されている場合､ ユーザーの入力や発生した他のアクションに基づいて動的に設定されている場合､ これは典型的なチェック方法です｡

ところで､ ここでやっていることは､ イコールtrueのショートカットで､ isLoggedIn､

つまりこの変数に格納されている値がtrueかどうかを比較しています｡

これは､ 二重の等号を省略した場合に実行されるデフォルトのチェックです｡

つまり､ ここでのif isLoggedInは､ もしtrueならと読めるので､ このチェックと等しいので､

変数や何らかの式を参照するだけならそれがデフォルトなので､ trueと等しいかどうかチェックするのは冗長です｡

先ほど述べたように､ これは2つのよくあるシナリオのうちの1つです｡ ある変数､ あるいはtrueまたはfalseを返す他の関数を呼び出す場合､

ここでtrueまたはfalseを返す何かをチェックし､ その何かが変数または関数呼び出しであることを確認します｡

もう一つの一般的なシナリオは､ ここに条件を書いて､ 2つ以上の値を直接比較することである｡

ユーザー名がMaxで､ 年齢が30だとします｡ ユーザー名がMaxと等しいときに､ ログインしている状態で何らかのコードを実行することを確認したいのです｡

もう少し現実的にするために､ パスワードも追加してみましょう､ テスター｡

ユーザー名とパスワードが正しい場合はこれを表示し､ そうでない場合はユーザーまたはコードの実行をelseブロックに移してfailedと表示します｡

このような場合､ ユーザー名とパスワードの値をチェックしたいので､ 真か偽かを表す単一の変数はありませんが､

ユーザー名がある値を持っているか､ パスワードがある値を持っているかをチェックしたいのです｡

このようなシナリオでは､

ユーザー名がMaxと等しいかどうかをチェックすることができます｡ そして､ これは今まで見たことがない新しいもので､

ここでの&&記号は､ 他の条件も真でなければならないことを意味し､ ここでは､

例えばパスワードがtesterと等しいかどうかをチェックします｡

このシナリオでは､ 2つの条件をチェックしていますが､

両方とも真でなければこのifブロックに入れません｡

このコードを実行すると､ ユーザー名がMaxで､ パスワードがtesterで､ ログインしていることがわかります｡

ダブルイコールはシングルのイコールとは全く違う意味ですのでご注意ください｡ ここでシングルの等号を使って変数に値を格納するのと､

ダブルの等号を使って変数の値を別の値と比較するのとでは､ 全く別のものです｡

このような比較､

いわゆるブーリアン比較演算子を使う場合､ 常にブーリアンが得られる｡

もちろん､ hasCorrectCredentialsなどのヘルパー変数を使うこともできます｡

つまり､ 両方の条件を満たした場合は真､

少なくとも1つが失敗した場合は偽という真偽値を導き出すために､ hasCorrectCredentialsに真か偽を格納し､ hasCorrectCredentialsを使用して真か偽を決定しています｡

しかし､ より一般的なケースは､ このようなヘルパー変数を使用せず､

if文の中に条件をそのまま記述することだと思われます｡

ここでは両方の条件を満たす必要がありますが､ 何らかの理由で､ ユーザーが20歳以上であればログインさせたい場合もあります｡

そこで､ ここにパイプ記号を2つ並べたor文を追加することもできます｡

ここでは､ "or "と "check"､ "age > 20

"を追加して､ もうひとつのブール型比較演算子とすることができる｡ 二重の等号の他に､ greater than､ greater

than or equal､ small than､ small than or equal､ さらに等号の前に感嘆符を付けたnot

equalがあります｡

ここでは等号が1つしか入っていないことに注意してください｡

つまり､ これらは代替演算子であり､

ここでは大なり演算子を使って､ 年齢が20より大きい場合にこの部分が真を返すようにしています｡

さて､ この全体的な表現をどう読み解くかですが｡

では､ パスワードを変更して､ この最初の部分が満たされないようにしたらどうなるか見てみましょう｡

今これを実行しても､

ログインしたままなので､ これはどうやったら読み取れるのでしょうか？

これは､ これが真でこれが真ならログインしてください､ あるいはこれが真でここが真でなく､ したがって､

ここの組み合わせは真でなく､ ここ､ これは真です､ またはなので､ これは前の偽を上書きし､

別の条件を満たすことができ､ この条件とこの条件が偽である場合のみ､ 我々はここで成功しないでしょう､

2つのまたは条件のどちらも真でないため｡

もちろん､

DartPadやif文で遊んでみて､ どのように設定できるのか､ 何ができるのか､ さまざまな演算子がどのように動作するのかを確認することは､

常に素晴らしいアイデアです｡

また､ 条件をデフォルトで解析されるのとは異なる方法で組み合わせたい場合もあります｡

つまり､ 「これとこれが真であるべきだ」と言う代わりに､ 「これは常に真であるべきだ」､ そして「これも真であるべきだ」と言いたいのでしょう｡

このチェックを組み合わせて､ ユーザー名が Max であればログインしていると言い､ パスワードが

tester か年齢が 20 より大きい場合はログインしていると言いたいのでしょう｡

今は､

これが本当でこれが本当ならログインしている､ またはこれが本当ならログインしていると読み取れます｡

パスワードチェックと年齢チェックを一緒にしたい場合は､ 数学の方程式のように括弧を使って､

この2つの条件が一緒になっていることを示します｡ つまり､ ユーザー名は常にMaxでなければならず､

正しいパスワードか正しい年齢でなければならないということです｡

つまり､ 現時点ではユーザー名がMaxなのでログインしていることになりますが､

ここでMaxをMaximilianに変更すると､ 実際にもう一度実行したときに失敗することがわかります｡

例えば､ 今加えた括弧を削除すると､ 実際にログインしていることがわかります｡ これは､

私がログインしているのは､ これが真か､ これが真か､

これが真かをチェックしているからで､ 最初の2つのチェックはどちらも真ではないが､

これは真なので､ ログインしていることになります｡

もちろん､ 比較演算子を正しく使うことも重要で､ not

equal演算子も非常に重要です｡

また､

より複雑なifチェックを行う場合もあります｡ ifとelse文だけでなく､

もしここで失敗したら､ 別のコードを実行するかもしれませんが､ そのコードも何らかの条件によって決まります｡

ここで､ もしこの条件が満たされなかったら､ この最初の条件が満たされなかったら､

次のブロックに進みます｡ それはelse if文で､ そこでさらに別の条件をチェックし､ この条件も満たされない場合にのみ､ このelseブロックに進みます｡

もしこの条件が満たされたら､ このelseブロックには入らず､

ここでisLoggedInがtrueかどうかをチェックします｡

そして､ この余分な括弧をもう一度上に追加すると､ 最初のチェックが失敗するので､ else ifブロックに入り､

ここでオーバールールを表示して､ この実行を確認しますが､ ここで実行ボタンを押すと､ もちろんisLoggedInがfalseなので失敗したと分かります｡

しかし､ これをtrueに設定するか､ 動的に導出してtrueを返すと､ 最初の条件が満たされなかったため､

else ifブロックが実行され､ オーバールールされたことがわかります｡

したがって､ 私たちはここに入り､

これをチェックし､ これは真であり､ したがって今､

私たちはこれを実行している､ その後､ 私たちはあまりにもelseブロックにそれを作っていないです｡

これらはif文で､ 基本的にどのプログラミング言語でも重要な構成要素であり､

したがってDartでも同様です｡ このコースでは､ これらをたくさん使用します｡ この講義が､ これらがどのように機能し､

どのように遊ぶことができるかを理解するのに役立てば幸いです｡

####
さて､ 今回もDartのディープダイブとして､ DART､ そしてFlutterに追加された比較的新しいコンセプトである､

もう一つの重要な価値を探ってみたいと思います｡

そしてそれは､ 値nullまたは値型nullと､ null safetyと呼ばれる概念になります｡

ここで､ NULL値とは何かを理解しましょう｡

これは特殊な組み込み値で､ 例えば値をリセットしたい場合などに非常に便利です｡

例えば､ usernameという変数があり､ その初期値がmaxであったとします｡

今度は､ アプリ内の任意の場所で､ ユーザーの入力から取得します｡

そして､ アプリのある時点で､ これをクリアしたい､ リセットしたいと思うはずです｡

さて､ このような場合､ どうすればいいかというと､ 空の文字列に戻すことができます｡

もうひとつ､ 「今は値を持ちたくない」という意思を表すのに使えるのが､

特殊なNULL値でしょうけど｡

ここでnullを使うと､ Dart PetとFlutterアプリでnullの安全性をオンにしたため､ エラーが発生します｡

また､ これをオンにしている場合もあります｡

さて､ NULL Safetyについては､ また後ほど｡

とりあえず､ このDart Petの下部にあるこのトグルをクリックすれば､ オフにすることができます｡

今､ この特別なnull値をusernameに代入していますが､

これは､ この時点のusernameはもう値を持つべきではない､

と言っているのです｡

このような場合､ 談話全体を通してnull値を格納する必要があるため､ nullは特別な種類の値であるという使用例が見られます｡

単純に､ ある時点の値を持ちたくないということを表現しているのです｡

ここに割り当てることで､ 何らかの値をリセットすることができるのです｡

あるいは､ これをコメントアウトすると､ 最初は値がない､ つまり､ 最初はusernameが値を含んでいないので､

最初はこれが実際にnullで､ ある時点で初めて値を割り当てるというシナリオも可能です｡

これは逆でしょう｡

今は最初は空の値ですが､ ある時点で値を代入します｡

ちなみに､ この方法は､ NULLセーフティを有効にした場合にも許可されます｡

でも､ これもまた､ ちょっとだけ｡

とりあえず消しておこう｡

つまり､ NULLは､ まだ値を割り当てていない場合に初期値として持つことができる値であり､

作業中の変数やプロパティをリセットしたりクリアしたりするために､ ある時点で明示的に割り当てる値でもあります｡

この null 値は､ ブール値の比較を行う場合に特に便利です｡ たとえば if 検査で username

に値がある場合のみ処理を行いたい場合､ username が null と等しくないかどうかを調べ､

null でない場合にのみ処理を行うことができます｡

それはあなたが書くことができるいくつかのコードであり､ その後､ 値を持っている場合にのみ続行されます｡

また､ 逆に意図的にnullを設定すれば､ そのようなコードの実行は避けられるでしょう｡

ここでも､ 純粋な理論であることは承知していますが､ 見てみましょう｡

このようなケースを使用し､ このコースを通してNULL値を見ることができます｡

しかし､ それはそれとして､ もう一つの重要なテーマであるヌルヌル安全性の話題に飛び込んでみましょう｡

NULL Safetyの考え方は､ DARTでは比較的新しいものであるため､ すべてがノリノリです｡

そして最終的には､ アプリケーションに潜むバグを回避することが重要なのです｡

そのため､ アプリケーションで発生する可能性のあるエラーは､ コードのどこかで値がNULLである可能性があるため､

それを処理しようとしている可能性があります｡

このように､ NULLかどうかを明示的にチェックするifチェックを使えば､ このifチェックの内部でユーザー名がNULLでないことを常に確認できるので､

このようなエラーを回避することができるのです｡

しかし､ このようなチェックを行わず､ ある値を使って作業を続けるというシナリオもあるでしょうし､

開発者として､ その値を使う時点ではNULLであってはならないと知っているかもしれません｡

しかし､ もしかしたら､ あなたのコードでは､ この値がnullになるとアプリケーションが実行時にクラッシュする可能性があるかもしれません｡

そして､ NULL safetyの背後にある考え方は､ DARTがそのようなシナリオをキャッチするために､ コードの裏側で特別なチェックを実行するというものです｡

そして､ ここまではもう少し具体的な例をお見せしましょう｡

そしてもちろん､ その質問と回答を出力する作業も行いました｡

そして､ 私が提供したこれらの開始ファイルでプロジェクトをセットアップしたのであれば､ それはうまくいくはずです｡

特に重要なのは､ pop speckled YAML ファイルで､ 環境を SDK greater two point 11 に設定することです｡

0.

ここで､ 例えば2より大きいなど､ 異なる設定をしている場合｡ 12ポイントゼロ｡

もし､ そのように設定を変更したら､ 実際にこれまで書いたコードでエラーが発生することになりますね｡

白いコールバックの代わりにここで関数を使用している場合､ 回答ダートでエラーが発生しますが､

それはこのヌルの件とは関係ありません｡

これは､ セレクトハンドラに期待する関数の種類をより具体的に記述したものが用意されている､

いわゆるvoidコールバックと呼ばれる値を返さない関数が欲しい､ とflutterが訴えているだけなのです｡

しかし､ main dartでは､ オブジェクト型クエスチョンマークの引数をパラメータ型stringに代入できないというエラーも発生します｡

Spectre YAMLファイルでこの環境を2以上に設定することで､ flutterプロジェクトでのNULL Safetyが有効になります｡

12.

と､ 2ちゃんに言ってしまったわけです｡ 11､ これはヌル・セーフティを無効にするためです｡

そしてそれは､ 私がお見せするコードが動作するため､ ここでは問題ありません｡

クラッシュしない｡

問題なく使えるでしょう｡

しかし､ NULLセーフティを有効にすると､ DARTはいくつかの余分なチェックを実行し､ この場合､ 存在しない問題について文句を言うことになります｡

そもそもその問題を解消するのはやはり考えものかもしれませんが､ ここでのコードでは実際の問題ではないことを強調しておきたいと思います｡

そして､ このNULL安全機能がリリースされる前に収録したので､ このコースを通して､

そのNULL安全チェックが､ 実際には問題でない問題を訴えて､ アプリの問題につながらないような状況がいろいろ出てくると思います｡

ここで､ それが訴えている問題は､ その問題文です｡

なぜなら､ DARTは私たちのコードを十分に理解しておらず､ 質問文がNULLになることはありえないからです｡

なぜなら､ 私たちがすべての質問を設定する方法は､ すべての質問テキストが非ヌル文字列値を持っていますが､ dartはそれを見るために私たちのコードを十分に理解していないのです｡

したがって､ このエラーメッセージのobjectの後にある疑問符は､ Dartがこれはオブジェクトの値かもしれないと考えていることを知らせているのです｡

もちろん､ 開発者として､ この場合､ 質問文がNULLになることはありえないことを知っていますが､

質問文を設定する方法は､ 質問文がNULL値を保持する質問はないことを保証しています｡

しかし､ それこそがヌル・セーフティで得られる問題なのです｡

コードに全く問題がない場合にも､ 余計なエラーが発生します｡

そして､ このコースでは､ この機能がリリースされる前に収録したため､ NULL safetyをオフにすることをお勧めしているわけです｡

そのため､ 余計な警告が出ず､ 私がお見せしたコードは全く問題ないにもかかわらず､ このようなエラーを引き起こすコードスニペットがあるのです｡

また､ DartがNULLになる可能性があると考える文の後に感嘆符を追加することで､ これが絶対にNULLにならないとDARTに思わせるようにコードを改良してみることもできます｡

そうすると､ ここで残る問題は､ ダートがこれが任意のオブジェクトであることを見抜くことである｡

つまり､ 文字列である必要はなく､ 任意の値です｡

しかも､ それがあまり嬉しくない｡

したがって､ この問題を解決するには､ 文字列として記述する代わりに､ ちょうどその1行下にリスト文字列として記述することです｡

あえてそうすることで､ 文字列の羅列になることを納得させた上でスタートします｡

今は､ これが文字列になることを納得させるためにやっています｡

そして､ その文字列を自動的にDARTに伝え､ 常に文字列であること､ 決してNULLなどではないことを伝えています｡

なぜなら､ 開発者である私は､ これが決してヌルにならないことを知っているからです｡

そうすれば､ 解決することができるのです｡

しかし､ 前にも述べたように､ ビデオで見たのと全く同じコードでスムーズについて行くには､ 環境SDKのバージョンを2以上に設定することをお勧めします｡

というのも､

そうすると､ 余計なNULL安全性チェックが無効になってしまうからです｡

そして､ 書くコードも同じです｡

コードは問題なく動作します｡

こういう間違ったエラーメッセージがないだけだろう｡

さて､ nullとnullの安全性についてのこの講義の締めくくりとして､ このダークパッドでの冒頭の例に戻りたいと思います｡

ここで､ NULLセーフティがオンになっている場合､ ここで文字列をNULLに設定すると､ エラーが発生したことを覚えているかと思います｡

今は文字列なのでエラーになりました｡

そして､ DARTはこの変数を文字列で初期化しているので､ この変数には文字列が格納されているはずだと推論します｡

しかし､ その後にnullを設定したところ､ nullは文字列ではありません｡

それは､ nullという別の型です｡

それを許可する場合は､ これをnullに設定する｡

したがって､ usernameが文字列またはnullであることをDartに伝えたい場合は､ このような書き方ではなく､

この変数の導入方法を変更しなければなりません｡

型名の後にこのクエスチョンマークを付けて､ このように書けばいいのです｡

これは､ Dartに「これは一般的に文字列であるべきだ」と指示しているため､ 数値などを格納することはまだ許可されていません｡

しかし､ オプションのクエスチョンマークを使うことで､ DARTに「これはNULL値も保持する可能性がある」と伝えることができるのです｡

そのため､ クエスチョンマークがないと､ やはり以前のようなエラーが出てしまいます｡

クエスチョンマークは､ Dartに「これは文字列であるべきだが､ もしNULLであっても構わない」と伝えるためのものです｡

したがって､ NULLセーフティを有効にしている場合､ 変数や関数パラメータ､ オブジェクトのプロパティを導入する際にこのクエスチョンマークを使用することで､

この変数パラメータやプロパティが主な値型を持つがNULLである可能性もあることをDARTに伝えることができます｡

そして､ NULL値とNULLの安全性については以上です｡

今のところ､ 私たちは様々な例で講義を通してnullを見ますが､ 前述の通り､ この講座はその機能がリリースされる前に収録されたため､

nullの安全性はここでは死守していません｡

しかし､ 私たちが書くコードはNULLで問題になることはないので､ 談話にも必要ないのです｡

####
では､ 3元式から始めましょう｡ したがって､ ここでは､ まず､ 条件があります｡

ここでの条件は､ ifキーワードがなくてもいい､

それが3元式の書き方だ｡

ここの条件は､ 上の条件と同じでも良いわけですが､

質問指数は質問長より小さいのですか？ この場合､ クエスチョンマークを追加すると､ これが真である場合に実行されるべきコードの境界をマークします｡

クエスチョンマークの後のものは､

この条件が真の場合に使用されるもので､ 次に､ これが真の場合に使用されるべきコードブロックの後にコロンを追加する必要があり､

クエスチョンマークの後のこの部分は､ 1つの式だけでなければなりません｡

あくまでコラムであって､ 他のものはコラムの中にあるんです｡

そのため､ このカラムの後にコロンを追加し､

いわゆるelseブロックを作成します｡

ここにelseブロックを追加して､

条件が満たされない場合に実行するコードを定義します｡ もしここで､ falseを返したら､

elseブロックに入ります｡ ところで､ このようなif文では､ else if文を使って､

最初の条件が満たされない場合にチェックされる他の条件を追加することもできますが､

今は無視しましょう｡ 本文の下にある3項式では､ else ifはありませんが､

メインコード､ 条件が満たされた場合､ そしてコロンの後にelseブロックがあり､

これはFlutterに組み込まれた別のウィジェットで､

ページ上のすべてのコンテンツを水平方向と垂直方向の中央に配置するセンターウィジェットになりえます｡

これは子プロセスを取り､

中央に配置されるウィジェットになります｡

このアプリケーションをリロードして戻ると､

回答を選択することができますが､ 3回目のボタンをクリックした後は､ エラーは表示されませんが､ 「完了しました」と表示され､ もちろんこの方がずっとすっきりしていて､

ユーザー体験も優れています｡

###
さて､ この3項式に何を追加したかというと､ DartとFlutterの両方の中核となる基礎的な部分を多くカバーしたのです｡

もちろん､ まだまだ学ぶべきことはありますし､

そうでなければ､ これ以上講座の内容を増やすことはできませんが､

重要な第一歩です｡

しかし､ この3元式はちょっと読みにくいかもしれませんね｡ 特に､ このように複雑な列が間にあるため､

何が起こっているのかが一目瞭然ではないかもしれませんし､

正直なところ､ それほど複雑でもないのです｡

このコースでは､ この列よりもはるかに複雑なウィジェット構造を使用することができますし､

今後も使用することになるでしょう｡ ウィジェットツリーをより読みやすく､ より管理しやすくしたい場合､

常に頭に浮かぶはずなのが､

その分割です｡ もちろん､ ウィジェットをサブウィジェットに分割することは可能ですが､

常に問題となるのは､

分割すべきかどうかということです｡

さて､ より大きなウィジェットに､ 互いに受け渡しする多くの異なるネストされたウィジェットがあると仮定しましょう｡

もちろん､

個々のタスクを担当するサブウィジェットに分割することもできますが､ 問題はそうするかどうかです｡

さて､ 一般的に､ これは本当に暗記できることですが､

Flutterでは､ 少ないウィジェットよりも多いウィジェットを作ることが常に推奨されています｡

もちろん､ 内蔵のウィジェットをいちいち自分のカスタムウィジェットに包むべきではありませんし､ ウィジェットを分割する適切なポイントがいつあるのか感覚的にわかるようになりますが､

全体としては､ 大きなウィジェットよりも小さなウィジェットを用意するほうがよいのです｡

読みにくいコードや絡まったコードよりも､

読みやすいコードのほうがいい｡

ですから､ このアプリケーションでは､ 列をここに置くだけでなく､ 中央のウィジェットを別のウィジェットにすることを検討する価値があるかもしれません｡

もちろん､ 中央のウィジェットはそれほど複雑ではないので､ このままでもいいのですが､

もっと内容を充実させる予定です｡

そこで､ ここでは新しいウィジェットとして､ クイズを2つ追加することにします｡ ダーツと結果 ダート 今､ 私のクイズで｡

dartファイルで､ ステートレスウィジェットであるquizを作成し､ そこにFlutterの素材をインポートしてみます｡ ダーツファイルを作成し､

メインにあるこの列を取ることができます｡ ダートファイルを取得し､ それをビルドメソッドの戻り値として､

そのコンテナの代わりにここに追加します｡

もちろん､ ここでは質問と回答のウィジェットを参照しているので､ ここで行うべきことは､

両方をインポートすることです｡ ダートで､ 輸入すべきです｡ /answerです｡ dartを使用して､ このファイルのウィジェットをアンロックします｡

私は質問リストと回答質問機能を参照しています｡

もちろん､ クイズをステートフルウィジェットにすることもできます｡

なぜなら､ 質問と答えの両方をここに持っているので､ このウィジェットですべてを管理できます｡

dartファイルで､

クイズではありません｡ dart ファイルを使用しないと､ 基本的に三項式もクイズに転送することになります｡

dart ファイルを使用します｡ その条件をメインで管理する必要があるからです｡ dartファイルでは､

ここに状態を保持しておきたいと思います｡

その代わり､ 私がやりたいのは､ ここのメインです｡ dartファイルでは､ 問題をインポートする代わりに､

クイズをインポートしています｡ この条件が満たされた場合､ クイズウィジェットを使用することができます｡

ボディとクイズウィジェットにしばしば疑問符が表示されますが､

質問リストと回答質問関数の両方を渡す必要があり､ これはもちろん､ 2つのレベルのウィジェットを介して回答質問関数を転送することを意味します｡

main.のMyAppウィジェットから渡しています｡ ダーツファイルをクイズウィジェットに転送し､

クイズウィジェットでは､ アンサーウィジェットに転送します｡ しかし､ それはそれであり､ それは我々が意味をなす最も高いレベルで状態を管理し､

我々はまた､ クイズや私たちの結果を表示するかどうかを制御することができ､

すぐにここに表示することができます無駄のないセットアップです｡

つまり､ quizに答えのポインタを転送したいし､ questionsも転送したいのですが､

先ほど忘れてしまったので補足すると､ questionsはクラス全体のプロパティになったので､

例えばここで質問インデックスと一致させるためには､ もちろん_questionsにするべきです｡

questionsを_questionsに変更し､

条件とそれを渡す場所のように､ それを使用するすべての場所で変更します｡

アプリの起動時に初期化され､

その後は変更されないランタイム定数値と､

マップのリストがあります｡ マップはそれぞれ異なる値を持ち､ 文字列キーとオブジェクト値を保持するため､

ここではネストしたジェネリック代入を行います｡ このウィジェットはプライベートではないので､ 他のファイルの内部から使用する必要があります｡

さて､ ちょっとした余談ですが､ もしここで「Function」が使われていることに関連するエラーが発生した場合､

現在でも将来でも､ これを「VoidCallback」に置き換えるだけでよいことは､ すでにコースで以前に述べたとおりです｡

ここでは､ まだ「Function」を使っていますが､ もしエラーが出るようなら､ 代わりに「VoidCallback」を使ってください｡

は､ 他のファイルの内部から使用する必要があります｡

ここではコンストラクタを追加し､

必須というわけではありませんが､ 混ぜるために名前付き引数を使用します｡

問題は､ どの質問を見ているのかを知る必要があることです｡

そこで､ 質問インデックスを整数で受け取り､

これをクイズウィジェットの名前付き引数として追加し､ ここで質問インデックスをアンダースコアなしで使い､ ここで質問にアンダースコアなしで答えることで､

すべてがうまくいくはずです｡

dart でこのクイズウィジェットを使用する場合､ これらの値を名前付き引数として渡さなければなりません｡

また､ 渡す前に､ これらの引数の前にrequired､

@requiredを追加したいのですが､ @requiredはmaterialが提供するデコレーターです｡ ダートで､ これらの値はすべて必須であり､ ひとつも省略してはならないことを基本的にFlutterに伝えます｡

ですから､ もしこのクイズウィジェットを1つまたは2つの引数だけで作成しようとした場合､

エラーが発生します｡

さて､ エラーについてですが､

もし「@required」でエラーが発生した場合､ あなたが使っているDartやFlutterのバージョンによっては､ 「@」なしで「required」だけを使ってください｡

そうすれば､ これでエラーになることはありません｡

もちろん､ クイズウィジェットを作成する必要があります｡ これは､ mainのMyAppStateクラスで行います｡

dartファイルです｡

クイズウィジェットを作成し､ 引数に値を設定してみましょう｡

カーソルを括弧の間に置いてコントロールスペースを押すと､

IDEのサポートが得られ､ answer questionは私の関数ポインタであり､ _answerQuestionを指すので､

MyAppStateクラスのここに私の関数があります｡ 質問インデックスで､ 私はここで私のMyAppStateクラスで管理されているプロパティである_questionIndexを渡したい､

そして質問で､ 私は_questionsを渡します｡

クイズウィジェットに転送されたデータでクイズウィジェットを作成しています｡

少し冗長に見えるかもしれませんが､ ここにカラムがあるよりもすっきりしていると思います｡

もちろん結果もアウトソースして､ センターウィジェットにしましょう｡

ここで結果を出す｡ dartで､

resultと名付けたステートレスウィジェットを再び作成し､ その中でpackage:flutter/materialをインポートしています｡ のダーツで､ コンテナを返す代わりに､

センターを返すようにしました｡

ここでresultウィジェットを使う必要があるので､

コロンの後にresultと記述します｡ もちろん､ それを利用するためには､ インポートする必要がありますが､

使うものは必ずインポートする必要があるので､ resultをインポートしましょう｡

ダート それでは､

この緑色の更新ボタンを押してアプリを再起動し､ 正常に動作するか確認してみましょう｡

質問と回答が表示されるので､

それをタップして､ ボタンを3回叩けば､ やったねということになるんです｡

もちろん､ それは以前と同じ結果のための多くの作業でしたが､ Flutterはきれいなコードときれいなウィジェットツリーを書くことでもあり､

私たちのメインでここにそのコラムがあるよりも読みやすくなっていると主張します｡

dartファイル､

特にここにどんどんロジックを追加していく場合､

アプリをウィジェットに分割していくのは良い習慣です｡

先ほど述べたように､ すべてのテキストを独自のカスタムウィジェットにまとめる必要はありませんが､

もう少し複雑なテキスト､ 数行､ より多くのロジックがある場合は､ そのために新しいウィジェットを作成することを強くお勧めします｡


###
このモジュールはかなり長かったので､ このクイズをもう少し現実的なものにし､

どの答えを選ぶかによって異なる結果を示すことで､ このモジュールをまとめ､ 終わりにしたいと思います｡

もちろん､ これを非常に複雑なものにすることもできますが､

ここでは比較的単純なものにします｡

そしてもちろん､ テキストやアンサーテキストなど､

好きな名前をつけることができます｡

ここで重要なことは､ この答えにスコアを割り当てたいと思うことです｡

例えば､ あなたが好きな色として黒を選んだ場合､ 私はあなたに10点を与えます｡

一方､ 赤の場合は､ 赤が私たちのテキストなので､

6点か5点にするかもしれません｡

緑は希望の色ですから､

さらにポジティブです｡ もちろん､ これらの色に対するあなたの個人的な判断に合わせて､

自由に点数をつけてください｡

テキストだけでなく､

地図も表示され､ テキストキーもありますが､ スコアも表示されます｡

もちろん､ 動物についても同じことができますので､ ここで早送りをします｡ もちろん､

ご自分の点数をつけてもいいですし､ 添付されている点数をつけてもいいですし､ 基本的にはこの質問リストに私の完成した点数をすべてつけて､

その後に進みます｡ ここで完成したリストで､ もちろん私が質問をクイズに渡すとき､

クイズウィジェットの内部でこれらの回答ウィジェットを構築するとき､ 私がここで転送する回答はもはや単なる文字列ではありません｡

したがって､

ここでマップを作成すると､ 回答もさまざまな値を持つマップになります｡

したがって､ ここで私はもちろん自分のテキストに興味があります｡

さて､ この「トータルスコア」を調べる前に､ ここでエラーが発生する可能性があります｡

そして､ この「質問テキスト」に関しても､

あなたはすでにこのことを理解していたはずで､ これらのエラーを解決するには､

単に「as String」をその後に追加すればよいでしょう｡

as String」が必要かどうかは､ 使用しているDartのバージョンに依存します

- - これはFlutterとは直接関係なく､ 代わりにDartに依存します｡

pubspec "では｡ yaml" この "環境: sdk: " が

>= 2 に設定されている場合｡

12. 0 (i. e. 2. 12以上）であれば､

"as String "を追加する必要があります｡

しかし､ スムーズにフォローするために､

代わりにこれを設定することはお勧めしません｡

に設定し､ Flutterのすべてを問題なく学べるようにするためには､ この値を >=2

に設定する必要があります｡ 11. 0.

その場合､ "as String "を省略しても､

コースで示されるコードに従うことは問題ありません｡

しかし､ もし「>= 2. 12. 0"､ 推奨されないとはいえ､ "as

String "を追加する必要があります｡

しかし､ ここで､ このようなtotalScoreも計算するようにしましょう｡

そして､ ここでanswerQuestionにそのために､

私たちがメインで持っているその関数に｡ ダーツファイルでは､ この_answerQuestion関数で､

実際に選択された答えのスコアを取得する必要があります｡

だから､ ここにスコアを引数として期待し､ これは整数であるべきで､ 合計スコアを計算する｡

したがって､ 我々はまた､ 全体のクラスで､ ここ_totalScore､ 合計スコアのプロパティを追加する必要がありますし､

ここでanswerQuestion､ 私は我々が選択したスコアを増加または合計スコアに追加したいのです｡

ちなみに､ このような設定をする場合､ Dartにはショートカットがあり､

古い値と新しい値を等しくする代わりに､ プラス等しいを使用すると､ この値を古い値に追加してから変数に保存します｡

そこで､ answerQuestionで今のスコアを合計スコアに追加しますが､

今度はクイズでそれを確認する必要があります｡ ここではanswerQuestionをanswerに転送していますが､

実際には選択されたスコアでanswer questionsを呼び出すことを確認しています｡

では､ どうすればいいのか？ クイズで｡ 回答ウィジェットを構築するダーツでは､

回答質問のポインタを転送しますが､ これを転送する代わりに､ 匿名関数を転送することができ､ ここでは先ほども紹介した1行の矢印関数構文を使用しています｡

こうすることで､ その場で関数を作成し､ アンサーウィジェットに､ 自動的にアドレスだけを渡すことができるのです｡

この関数はその場で作られ､ メモリに格納されます｡ そして､ ここで使えるアドレスを保持する変数に格納する代わりに､

自動的にアドレスを取得するのです｡

つまり､ 私の答えのウィジェットは､ 引数を取らない関数､ つまり空のリストを取得し､

その関数が何かをするということです｡

しかし､ この矢印の右側では､ 匿名関数の関数本体にいます｡

そこで､ ここでは､ アドレスを使うのではなく､ answerQuestionを呼び出したいのです｡

これはDartがこれを解析するときには実行されず､ この匿名関数を作成してメモリに保存するだけですが､ onPressedがトリガーされたときには実行されます｡

これは匿名関数で､ answerにアドレスを転送し､ そのアドレスがここのボタンにバインドされているので､ ボタンが押されるとこのアドレスを使ってこの匿名関数が実行されます｡

つまり､

この関数本体は､ ボタンが押されたときだけ起動されるのです｡

なぜなら､ ここでループしているすべての回答は､

テキストとスコアを持つ単なるマップであり､ ここでそのスコアにアクセスできるからです｡

このため､

answerQuestionに回答スコアを転送することができます｡ これは整数になるため､ answer questionは私の整数のスコアを受け取ることができます｡

この流れが理解できればいいのですが､

実際には関数参照を渡すだけで､ ここではそのような関数､ したがってそのような関数参照もその場で作成しています｡

この関数はボタンが押されたときだけ実行されるので､

ボタンが押されたらもちろんここでこの関数を実行したい｡ それで､ このスコアをmainのanswer question関数に転送して､

合計スコアを増加させることができるのです｡

その合計点を結果ウィジェットに転送して､ 異なる結果を表示できるようにしたいのです｡

####
このresultに､

int型の最終プロパティを追加して､ resultScoreとか好きな名前をつけて､

コンストラクタを追加して､ 位置引数として､ もちろん､ 名前付きの引数を使うこともできますが､ ここでは､ これを位置引数として､ 私のスコアを持っていきます｡

この結果ウィジェットを使うときは､ スコアを転送する必要があります｡

MyAppStateクラスでtotal scoreプロパティとanswerQuestion関数を使って計算した合計スコアはresultに転送され､

resultではコンストラクタでこれを受け取り､ このショートカットのおかげで自動的にresultScoreプロパティに保存されます｡

あとは､ 結果のスコアに応じて､ ここに異なるテキストを出力したいだけです｡ まず最初に､ ここにスタイルを割り当てましょう｡

これは先ほど行ったので､ TextStyle クラスとテキスト・ウィジェットの

style 引数の助けを借りて行います｡

大胆に FontWeightは基本的にユーティリティで､

いくつかの定義済みの値をグループ化するグルーパークラスです｡

それでも､ 私たちは異なるテキストを必要とし､ 今これを生成する異なる方法を取得します｡

私はここでゲッターを追加する方法が好きです｡ ここでのゲッターは特殊なタイプのプロパティで､

基本的にはプロパティとメソッドを混ぜたものです｡

ゲッターを作るには､ まずどのタイプの値を取得したいのかを定義します｡

メソッドとは異なり､ ゲッターは引数を受け取ることができないメソッドのようなものなので､ 括弧を追加する必要はありません｡

しかし､ ボディを追加し､ そのボディで文字列を返す必要があります｡ ゲッターでは常に何かを返さなければなりませんが､

それを通常のプロパティのように使用します｡

これは関数ではなく､

単なるDartの機能で､ 通常のプロパティですが､

値は動的に計算され､ ここでは計算したい値は結果のスコアに基づいて計算されます｡

このゲッターの本文で､ 名前の衝突を避けるために新しい変数result

textを作成し､ デフォルトを割り当てます｡

もしそうなら､ ここで中括弧の間に､ result textをyou are awesome and innocentに等しく設定することになります｡

この新しい値でresultテキストを上書きしています｡

else ifは､

先ほども言いましたが､ これまで使っていなかったもので､

この条件が満たされない場合に実行されるelse文です｡

だから､ もし8より小さいか等しくないのなら､ 12より小さいか等しいかもしれない｡

その場合､ 私はリザルトのテキストを､ eを追加したpretty likableに設定することにしています｡ このクイズは､ スコアが高いほどネガティブな性格であることを意味します｡

そこで､ その場合は､ result

textをyou are strangeとし､ それ以外の場合は､ you are so badとすることにしています｡

もちろん､ 全体的なelseケースはここにあるので､ 初期値は必要ありません｡ なぜなら､ 初期値は決して保持しないので､

少なくともこのelseブロックには入れるでしょう｡

その場合､ 最終的にresult textに格納される型を文字列で定義するのがよい方法です｡

ここで最終的に結果テキストを返すので､ ここでresultPhraseを使用すると､

取得した結果スコアに基づいて､ ユーザーが行った選択に基づいて異なる結果を出力する必要があります｡

では､

ここでこのアプリケーションをリロードして､

今度はネガティブな性格を探ってみましょう｡

黒が好き､ 蛇が好き､ ここではすべてが正しく､ あなたはとても悪いとわかります｡

これでよし､ この緑色のボタンでアプリを再起動しましょう｡

もちろん､ ここにボタンがあればいいのですが､ 今のところ､ それはありません｡

では､ そのリロードを待って､

今度は性格の良い､ 白､ それからウサギが好き､

もちろん自分も好き､ あなたはすごい､ 無邪気だ､ と言ってみましょう｡

もちろん､

テキストが中央に配置されていないことに気づきました｡

ダーツファイルでは､ テキストウィジェットのここで､ textAlignをTextAlignに設定することができます｡ センターリング､

これも先ほどやったことですが､ これを保存するとセンターリングされるようになりました｡

このように､ さまざまな選択肢に基づいてさまざまな結果が表示されるようになり､

これまでに作った中で最も素晴らしいアプリケーションとは言えないかもしれませんが､ 現実的なアプリケーションが完成しました｡

####

さて､ これを仕上げて､ 結果画面の中からクイズを再開できるようにするために､

結果画面で､ 問題の進捗をリセットするために押すことができるボタンがあることを確認しましょう｡

どうすればいいのか？

他のものの下にものを追加したり､ 他のウィジェットの下にウィジェットを追加するにはどうしたらよいでしょうか？

さて､ コラムが必要ですね｡ 以前は手動で行っていましたが､ IDEにインストールされたFlutter拡張機能を使えば､

自動でリファクタリングを行うことができます｡

リファクタリングのショートカットがどれかわからない場合は､

キーバインディングにあるショートカットを使って､ カーソルをここに置いて､ テキストをクリックして､ ショートカットを押します｡

それがない場合は､

少なくとも新しいウィジェットでラップし､ 手動でカラムを作成することができます｡

Enterキーを押すと､ 自動的に列が作成され､ テキストはすでにこの子配列に格納されています｡

これを保存すると､

中央揃えが失われます｡ これはデフォルトの動作で､ デフォルトでは列がビューポート､

つまり画面の利用可能な高さをすべて使用するためです｡

ここでもう一つRaisedButtonを追加することもできますが､ FlatButtonを追加します｡

FlatButtonは基本的に背景色のないボタンで､ それ以外は通常のボタンです｡

基本的にはボタンに表示されるコンテンツで､ ここではテキストで十分なので､

restart quizとします｡ また､ RaisedButtonと同じように､

onPressedハンドラも必要です｡ これで､ onPressedには関数参照が必要なこと､ 関数のアドレスが必要なこと､ 実際に再起動することは､ おそらくmainで行わなければならないいくつかのロジックであることがわかりました｡

ダーツファイルは､

現在の問題インデックスと総スコアを管理する場所であり､ 再起動するために両方をゼロにリセットする必要があるからです｡

だから､ メインで｡ MyAppStateクラスに新しいメソッド､

reset quizまたはあなたがそれを呼びたいものを追加することができます｡ ここでの目標は､ 質問インデックスと合計スコアの両方をゼロに戻すことです｡

さて､ これでリセット関数ができたわけですが､ これをmainで使う必要があります｡

を､

MyAppState クラスに追加していますが､ 結果ウィジェットの内部でトリガーしたいのです｡ しかし､ これは以前にもやったことで､ 単にその関数へのポインタを結果ウィジェットに渡すだけでいいのです｡

そこで､

括弧のないリセットクイズを結果ウィジェットに渡し､ 結果ウィジェットでは､ これを受け入れる必要があります｡

つまり､ 第2引数として受け取ったものはすべてリセット・ハンドラに格納され､

それがonPressedにバインドされることになります｡

ここで､ リセットハンドラをバインドして､ 保存すると､

再起動クイズが表示されます｡ また､ 余談ですが､ もしエラーが発生した場合は､

「final Function」の代わりに､ 「final VoidCallback」にしてください｡

そこで､ "final VoidCallback "とすることで､ このトリックを実行します｡

final Function "でエラーになる場合｡

ここで､ リセットハンドラをバインドして､ これを保存すると､

再起動クイズが表示され､ これを押すと､ 確かに再起動されます｡ これをもう少し目立たせるために､ FlatButtonに色をつけたり､

テキスト色をつけたり､ 青を使ったりして､ ボタンがもう少しよく見えるようにしましょう｡

これで､

リセットできるようになりました｡

しかし､ ユーザーインターフェースの構築､ アプリケーションのスタイリング､ そしてレイアウトについてもっと学び､

カラムを使用しているときに縦方向にセンタリングすることもできるようにします｡

この点については､

コース後半で詳しく説明します｡ とりあえず､ Flutterについて知っておくべきコアな基礎知識を一通り見てもらいました｡


####
Maximilian: さて､

このコースのセクションではFlutterの基本についてたくさん学びましたが､

おそらくお気づきかと思いますが､ Flutterの最近のバージョン､ 正確にはFlutter 2より大きいバージョンを使っている場合､ 使用したボタンに対して非推奨の警告が表示されます｡

そして､ そのボタンについては､ すでに紹介した講義の中でお話ししました｡

さて､ この講座では､

これらのボタンをたくさん使っていきます｡

また､ RaisedButton､ FlatButton､

そしてOutlineButtonは､

これまで使っていませんでしたが､

使用することができます｡

このコースは非推奨になる前に収録されたので､

このコースでは古いボタンを引用して使っています｡

なぜなら､ これらのボタンは非推奨であるにもかかわらず､

世界中の多くのプロジェクトで使用されているからです｡

そして､ それらを間違っていないとして使用することができます､

彼らはここにあり､ 彼らはまた､ 今後何ヶ月もの間､ 周りに固執することになります｡

Visual Studio Codeの非推奨の警告がうっとうしい場合は､

設定でdeprecatedを検索し､

非推奨の表示オプションを無効にすることで､

この事実を無効にできます｡

これは代替案であり､ そうする必要はありませんが､

既存のボタンに従うのであれば､ そうすることも可能です｡

しかし､ もちろん切り替えることもできます｡

これらのボタンに対応した新しいものに切り替えて､ これらに沿って操作することも可能です｡

それだけで立派ですし､ もちろん､ もう少し将来性もあります｡

そこで､ この講座では､

旧ボタンから新ボタンへの切り替え方法､

特にボタンにスタイルがある場合の切り替え方法を紹介します｡

また､ RaisedButton､ FlatButton､

OutlineButton以外のボタン､

例えばフローティングアクションボタンやアイコンボタンなどは非推奨ではありません｡

非推奨となるのは､ この3つのボタンです｡

そのため､ もしあなたがFlutter

2を使っていて､ RaisedButton､

FlatButton､ OutlineButtonをコードで使っているなら､ Visual

Studio Codeでこのストライクスルー効果が表示されるかもしれません｡

さて､ すぐに最も重要なメッセージは､

「もう使うべきではないけれども､ 絶対に使ってもいい」ということです｡

このシンプルなデモ・アプリケーションを実行すると､

3つのボタンをレンダリングするだけですが､

画面上に3つのボタンが表示され､

実際に動作して､ ボタンを押してもエラーにならず､

すべて動作します｡

このボタンを押すと､ 下の方にログが出力されるんです｡

だから使い続けられるし､ 今すぐ全部を変える必要はないんです｡

また､ 引用符で囲まれた古いボタンは､

他のリソースやサンプルアプリ､ 既存のプロジェクトのコードベースなどで多く使用されています｡

というのも､ まだ多くのリソースがこの古いボタンを使っているからです｡

もちろん､ これらのボタンに固執する代わりに､

新しい同等品に移行することもできます｡ なぜなら､ これらの古いボタンは､

代わりに使用すべき新しいボタンウィジェットが導入されたため､

非推奨となったからです｡

そして､ これから数分かけて､ これらの新しいボタンに順次移行していく予定です｡

そして､ RaisedButtonから始めましょう｡

RaisedButtonはElevatedButtonに置き換わります｡

ElevatedButtonはこれらの引数をサポートしていないので､

今のところ､ colorとtext colorを削除しなければなりませんが､

もしカスタムカラーのないボタンがあれば､ この新しいボタンへの移行は､ 名前を入れ替えるだけで簡単にできます｡

なぜなら､ それだとRaisedButtonの代わりにElevatedButtonになってしまうからです｡

そして､ これを保存すると､ このボタンはまだレンダリングされており､ 今はこのElevatedButtonを使っています｡

ElevatedButtonは､

舞台裏で､ アプリケーションによって設定されたメインのテーマカラーを自動的にピックアップするからです｡

そしてそれは､ ここでのこのケースではブルーなのです｡

そのため､ 自動的にテーマに沿ったスタイルになります｡

これは新しいボタンの利点の1つで､

スタイルを手動で追加する必要がなく､ テーマに合った基本的なスタイルがすぐに得られます｡

もちろん､ 手動でテーマカラーを上書きしたり､

その他のスタイルを追加することも可能です｡

そして､ それが旧ボタンと新ボタンの最大の違いです｡

以前のボタンは､ ボーダー側の端の文字色など､

スタイルを設定するための余分な引数がありました｡

新しいボタンには､ それがないんです｡

その代わり､ 新しいボタンには新しいstyle引数が1つあり､ それを設定することでこのボタンにスタイルを設定することができます｡

そして､ style はボタン スタイル オブジェクトを必要とし､

ボタン スタイル クラスをインスタンス化することで構築されます｡

そして､ このボタンのスタイルクラスで､

このボタンにあらゆる種類のスタイルを設定することができます｡

例えば､ ここでは背景色と前景色を使って､

テキストエディタの背景色を制御しています｡

前景色は､ 見たままの文字を設定します｡

背景色は､ 塗りつぶし色に設定します｡

つまり､ 背景色が青で前景色が白の

RaisedButton を作成する場合､ ここで背景色を設定することができますが､

開始色が青にならないため､ このような使い方はしません｡

その代わりに､ マテリアルステートプロパティallを使用して､

色､ 青色を渡します｡

少し奇妙に見えるかもしれませんが､

これは､ このボタンのスタイルオブジェクトの背景色の引数に色を割り当てる方法です｡

また､ 前景色はマテリアル状態のプロパティである全色ホワイトです｡

そして､ これを設定すると､ この青いボタンが残ることになります｡

しかし､ 例えば､ 背景色をオレンジ色に切り替えて保存すると､

オレンジ色のボタンが表示されるようになります｡

このように､ 新しいボタンにスタイルを設定するには､

このようなボタン スタイル オブジェクトを受け取る追加のスタイル引数を使用します｡

さて､ このようにスタイルを割り当てるのは少し煩わしいので､

特にこのように色に穴を開けるのは煩わしいので､

このボタンにこのスタイルを派生させる別の方法があります｡

ElevatedButtonを使用することができますが､ その後インスタンス化せず､

そこのメソッドからスタイルを呼び出すようにします｡

そして､ このstyle fromメソッドで､ primaryのようないくつかのスタイリング引数を取得し､

primaryに直接colors blueのような色を設定することができる｡

そして､ このボタンを構成するすべてのパーツに影響を与えることになるのです｡

ElevatedButtonの場合､

ボタンには背景色があるので､

明るい一次色のターゲットになるのは背景色です｡

原色でコンテンツの色をコントロールするために､ 一次引数で立ち上がったんですね｡

この場合､ 背景の上に描画色を置いているので､ この2色のドットの白を濃くすることができるわけです｡

例えば､ これをオレンジ色に変更すると､

背景と前景の色を設定する方法が簡単になります｡

そして､ 2つのアプローチのどちらを使ってもいいのです｡

このボタンのスタイルオブジェクトを作成し､

背景色と前景色を設定します｡ これは非常に明示的ですが､

少し長いです｡ または､ このスタイルからメソッドを使用して､

プライマリとオンプライマを設定します｡

この講義には､ 公式のボタン移行ドキュメントへのリンクも添付されています｡

このドキュメントでは､ ボタンの移行方法と､ これらのボタンのスタイリングについてもう少し掘り下げて説明します｡

そのため､ その資料もご覧いただけます｡

これがElevatedButtonで､

以前のRaisedButtonにあたります｡

FlatButtonの次は､

TextButtonです｡

TextButtonはFlatButtonに代わるもので､

ElevatedButtonと同様に､

これらの個々のスタイル引数はもう持っていません｡

その代わり､ style引数を1つ持ち､

ここでもインスタンス化することでボタンのスタイルを設定し､

そこでテキストを制御するための前景色と､

背景色を追加したい場合は背景色を設定することが可能です｡

デフォルトでは､ TextButtonは背景を持ちません｡

なぜなら､ TextButtonの背後にあるアイデアは､

背景色を持たないテキストだけだからです｡

しかし､ このボタン・スタイルに前景や背景､

その他のスタイルを設定する代わりに､ ここでもTextButtonスタイルを使用し､

ここで主な色をドット・ブルーやオレンジに設定することができます｡

では､ 違いはあったのでしょうか？

今これを保存すると､ 文字がオレンジ色になるのですが､

これが重要です｡

プライマリーとは､ 必ずしも背景色を指すのではなく､

このボタンを構成する主要なものを指すのです｡

そして､ ElevatedButtonの場合､

主要な要素は背景です｡ なぜなら､ それがElevatedButtonを構成する主なものだからです｡

背景があるボタンなので､

プライマリーターゲットにはその背景を｡

また､ プライマリーターゲットであるフォアグラウンドやTextButtonでは､

プライマリー要素はテキストであり､ したがってプライマリーターゲットはテキストカラーとなります｡

ここでは､ TextButtonが背景色を持たないということなので､

設定できるon primary引数もありません｡

背景色が必要な場合は､ ElevatedButtonを使用します｡

というわけで､ FlatButtonの翻訳ができるようになりました｡

さて､ OutlinedButtonについては､

新しいアウトライン化されたボタンが出来上がりました｡

つまり､ このDが重要で､ これが古いOutlinedButtonを置き換えることになります｡

ここでは､ 個々のスタイル・プロパティがない代わりに､

新しい style 引数をここに追加して､ これをボーダー・スタイルに設定し､

ボーダー側を表す side のような個々のスタイル要素をターゲットにすることができます｡

色の境界線は､ OutlinedButtonのスタイルを使用しています｡

そして､ ここでも､ 例えば､ 原色をcolors

dot orangeに設定できます｡

そうすると､ 今度はテキストがオレンジ色になることにお気づきでしょう｡

ボーダーを再スタイリングするために､

このサイトの引数を設定します｡

ボーダーサイトコンストラクタを呼び出してボーダーサイドオブジェクトを作成し､

ボーダーサイトの色を設定することができます｡

だから､ 全体的にボーダーの｡

そして､ 今これを保存すると､ オレンジ色のボーダーが表示されます｡

そうすることで､ 古いボタンから新しいボタンに移行することができるんです｡

RaisedButtonはElevatedButtonに､

FlatButtonはTextButtonに､

OutlinedButtonはOutlinedButtonにDを追加したものになります｡

色やスタイルを設定しないシンプルなケースでは､ ウィジェット名を入れ替えるだけで､

独自の色やスタイルを追加する複雑なボタンにすることができます｡

そこでは､ 個々のスタイル引数の代わりに､ このスタイル引数を追加します｡

そして､ 前景色､ 背景色などのボタン・スタイル・オブジェクトを作成するか､

ボタン・クラスでこれらのスタイル・メソッドを使用して､ 原色､

背景色､ ボーダー色などを割り当てます｡

さて､ 先ほども言いましたが､

旧来のボタンにもこだわりがあります｡

もちろん､ 新しいボタンに移行することもできますし､

移行はそれほど難しいことではありません｡

名前を入れ替えたり､ スタイル引数を追加したりすることで､

最終的に使い勝手がよくなります｡


####
そこで､ このモジュールでは､ 最初の小さなアプリケーションを作りました｡

もちろん､ もっと美しいアプリケーションを作ることはできますし､

それはこのコースで学ぶことでもあります｡

アプリのスタイルやレイアウト､ 色の変更､ ウィジェットの調整など､ あなたのニーズや好みに合わせて､

さまざまな方法をご紹介していきますので､ ご安心ください｡

ウィジェットとは何か､ ステートフルとステートレスのウィジェットがあること､

ステートフルよりもステートレスを使うことが多いこと､ どちらも重要であること､

そしてそれらがどのように機能するかを説明しました｡

内蔵ウィジェットの扱い方と､ 公式ウィジェットカタログのどこにあるのかを学びました｡ また､ Flutterが提供する基本的なウィジェットから､

より複雑なユーザーインターフェースのビルディングブロックを構成する独自のウィジェットを作ることができます｡

データを管理する方法､

データをコンストラクターの引数として渡す方法､ そしてDartとその中核となる基礎的な部分について多くを学びました｡

もしまだやっていなければ､

このモジュールの最終講義の添付資料やテキスト講義に飛び込んで､ 特にコードの比較をしてみてください｡

これらのリソースがあれば､

Flutterとは何か､ どのように動作し､ どのようにウィジェットを構築するのかについて､ まず理解できるはずです｡

もちろん､ コース全体を通してこの作業を続け､ 他の機能やDartとFlutterでできることについてさらに深く掘り下げていきます｡

では､ 次に進みましょう｡